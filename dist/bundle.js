/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (true) {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Remove event specific arrays for event types that no\r\n  // one is subscribed for to avoid memory leak.\r\n  if (callbacks.length === 0) {\r\n    delete this._callbacks['$' + event];\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  var args = new Array(arguments.length - 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    args[i - 1] = arguments[i];\r\n  }\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/component-emitter/index.js?");

/***/ }),

/***/ "./node_modules/extend/index.js":
/*!**************************************!*\
  !*** ./node_modules/extend/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n//# sourceURL=webpack:///./node_modules/extend/index.js?");

/***/ }),

/***/ "./node_modules/loadimages/index.js":
/*!******************************************!*\
  !*** ./node_modules/loadimages/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function loadimages(imgSrcs, then) {\n  // Parameters\n  //   imgSrcs\n  //     array of image source paths OR single source path string.\n  //   then(err, imgElements)\n  //     Will be called after all the images are loaded. If string was given,\n  //     imgElements is an Image instead of array of Images.\n\n  var numberOfImages, stringGiven, thereWasSuccess, thereWasError, imgs;\n  var onloadsCalled, onload, onerror;\n\n  if (typeof then !== 'function') {\n    throw new Error('callback should be a function: ' + then);\n  }\n\n  if (typeof imgSrcs === 'string') {\n    numberOfImages = 1;\n    stringGiven = true;\n    imgSrcs = [imgSrcs]; // Normalize\n  } else {\n    // Array of images\n    numberOfImages = imgSrcs.length;\n    stringGiven = false;\n  }\n  thereWasSuccess = false;\n  thereWasError = false;\n\n  imgs = [];\n\n  onloadsCalled = 0;\n  onload = function () {\n    // Note:\n    //   this = Image\n    if (!thereWasError) {\n      onloadsCalled += 1;\n      var isFinalImage = (onloadsCalled === numberOfImages);\n      if (isFinalImage) {\n        thereWasSuccess = true;\n        if (stringGiven) {\n          then(null, imgs[0]);\n        } else {\n          then(null, imgs);\n        }\n      }\n    }\n  };\n\n  onerror = function (errMsg) {\n    // Note:\n    //   this = Image\n\n    // No errors after success.\n    if (!thereWasSuccess) {\n      thereWasError = true;\n      then(errMsg, null);\n    }\n\n    // Prevent firing the default event handler\n    // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers.onerror#Parameters\n    return true;\n  };\n\n  for (i = 0; i < imgSrcs.length; i += 1) {\n    imgs.push(new Image());\n    imgs[i].onload = onload;\n    imgs[i].onabort = onerror;\n    imgs[i].onerror = onerror;\n    imgs[i].src = imgSrcs[i];\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/loadimages/index.js?");

/***/ }),

/***/ "./node_modules/monotone-convex-hull-2d/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/monotone-convex-hull-2d/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = monotoneConvexHull2D\n\nvar orient = __webpack_require__(/*! robust-orientation */ \"./node_modules/robust-orientation/orientation.js\")[3]\n\nfunction monotoneConvexHull2D(points) {\n  var n = points.length\n\n  if(n < 3) {\n    var result = new Array(n)\n    for(var i=0; i<n; ++i) {\n      result[i] = i\n    }\n\n    if(n === 2 &&\n       points[0][0] === points[1][0] &&\n       points[0][1] === points[1][1]) {\n      return [0]\n    }\n\n    return result\n  }\n\n  //Sort point indices along x-axis\n  var sorted = new Array(n)\n  for(var i=0; i<n; ++i) {\n    sorted[i] = i\n  }\n  sorted.sort(function(a,b) {\n    var d = points[a][0]-points[b][0]\n    if(d) {\n      return d\n    }\n    return points[a][1] - points[b][1]\n  })\n\n  //Construct upper and lower hulls\n  var lower = [sorted[0], sorted[1]]\n  var upper = [sorted[0], sorted[1]]\n\n  for(var i=2; i<n; ++i) {\n    var idx = sorted[i]\n    var p   = points[idx]\n\n    //Insert into lower list\n    var m = lower.length\n    while(m > 1 && orient(\n        points[lower[m-2]], \n        points[lower[m-1]], \n        p) <= 0) {\n      m -= 1\n      lower.pop()\n    }\n    lower.push(idx)\n\n    //Insert into upper list\n    m = upper.length\n    while(m > 1 && orient(\n        points[upper[m-2]], \n        points[upper[m-1]], \n        p) >= 0) {\n      m -= 1\n      upper.pop()\n    }\n    upper.push(idx)\n  }\n\n  //Merge lists together\n  var result = new Array(upper.length + lower.length - 2)\n  var ptr    = 0\n  for(var i=0, nl=lower.length; i<nl; ++i) {\n    result[ptr++] = lower[i]\n  }\n  for(var j=upper.length-2; j>0; --j) {\n    result[ptr++] = upper[j]\n  }\n\n  //Return result\n  return result\n}\n\n//# sourceURL=webpack:///./node_modules/monotone-convex-hull-2d/index.js?");

/***/ }),

/***/ "./node_modules/nudged/index.js":
/*!**************************************!*\
  !*** ./node_modules/nudged/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\n*/\nexports.Transform = __webpack_require__(/*! ./lib/Transform */ \"./node_modules/nudged/lib/Transform.js\")\nexports.estimateI = __webpack_require__(/*! ./lib/estimateI */ \"./node_modules/nudged/lib/estimateI.js\")\nexports.estimateT = __webpack_require__(/*! ./lib/estimateT */ \"./node_modules/nudged/lib/estimateT.js\")\nexports.estimateS = __webpack_require__(/*! ./lib/estimateS */ \"./node_modules/nudged/lib/estimateS.js\")\nexports.estimateR = __webpack_require__(/*! ./lib/estimateR */ \"./node_modules/nudged/lib/estimateR.js\")\nexports.estimateTS = __webpack_require__(/*! ./lib/estimateTS */ \"./node_modules/nudged/lib/estimateTS.js\")\nexports.estimateTR = __webpack_require__(/*! ./lib/estimateTR */ \"./node_modules/nudged/lib/estimateTR.js\")\nexports.estimateSR = __webpack_require__(/*! ./lib/estimateSR */ \"./node_modules/nudged/lib/estimateSR.js\")\nexports.estimateTSR = __webpack_require__(/*! ./lib/estimateTSR */ \"./node_modules/nudged/lib/estimateTSR.js\")\nexports.version = __webpack_require__(/*! ./lib/version */ \"./node_modules/nudged/lib/version.js\")\n\nexports.create = function (scale, rotation, tx, ty) {\n  // Create a nudged.Transform instance by using more meaningful parameters\n  // than directly calling 'new nudged.Transform(...)'\n  //\n  // Parameters:\n  //   scale\n  //     number, the scaling factor\n  //   rotation\n  //     number, rotation in radians from positive x axis towards pos. y axis.\n  //   tx\n  //     translation toward pos. x\n  //   ty\n  //     translation toward pos. y\n\n  if (typeof scale !== 'number') { scale = 1 }\n  if (typeof rotation !== 'number') { rotation = 0 }\n  if (typeof tx !== 'number') { tx = 0 }\n  if (typeof ty !== 'number') { ty = 0 }\n\n  var s = scale * Math.cos(rotation)\n  var r = scale * Math.sin(rotation)\n  return new exports.Transform(s, r, tx, ty)\n}\n\nexports.createFromArray = function (arr) {\n  // Create a nudged.Transform instance from an array that was\n  // previously created with nudged.Transform#toArray().\n  //\n  // Together with nudged.Transform#toArray(), this method makes an easy\n  // serialization and deserialization to and from JSON possible.\n  //\n  // Parameter:\n  //   arr\n  //     array with four elements\n\n  var s = arr[0]\n  var r = arr[1]\n  var tx = arr[2]\n  var ty = arr[3]\n  return new exports.Transform(s, r, tx, ty)\n}\n\nexports.estimate = function (type, domain, range, pivot) {\n  // Parameter\n  //   type\n  //     string. One of the following:\n  //       'I', 'T', 'S', 'R', 'TS', 'TR', 'SR', 'TSR'\n  //   domain\n  //     array of 2d arrays\n  //   range\n  //     array of 2d arrays\n  //   pivot\n  //     optional 2d array, does nothing for translation estimators\n  //\n  var name = 'estimate' + type.toUpperCase()\n  if (exports.hasOwnProperty(name)) {\n    return exports[name](domain, range, pivot)\n  } // else\n  throw new Error('Unknown estimator type: ' + type)\n}\n\n\n//# sourceURL=webpack:///./node_modules/nudged/index.js?");

/***/ }),

/***/ "./node_modules/nudged/lib/Transform.js":
/*!**********************************************!*\
  !*** ./node_modules/nudged/lib/Transform.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nvar Transform = function (s, r, tx, ty) {\n  // Public, to allow user access\n  this.s = s\n  this.r = r\n  this.tx = tx\n  this.ty = ty\n}\n\n// Default epsilon to use when coping with floating point arithmetics.\n// JavaScript floating point numbers have 52 bits in mantissa (IEEE-754).\n// That is about 16 base10 numbers. Therefore the epsilon should be\n// much larger than 1 * 10^-16. Let say 1 * 10^-10 is a good one.\nTransform.EPSILON = 0.0000000001\n\nvar proto = Transform.prototype\n\nproto.almostEquals =\nproto.almostEqual = function (t, epsilon) {\n  // Are transforms almost equal? Return true if a matrix norm\n  // of the difference is smaller than epsilon. We use modified L1 norm\n  // that values s, r, tx, and ty as equally important.\n  //\n  // Parameters:\n  //   t\n  //     Transform\n  //   epsilon\n  //     optional number, default to Transform.EPSILON.\n  //     Set to 0 for strict comparison.\n  //\n  // Note:\n  //   We first thought to use Frobenius norm but it felt wrong\n  //   because it exaggerates s and r. Proof:\n  //     We know Frobenius norm for real square matrices:\n  //       Norm(A) = sqrt(sum_i(sum_j(a_ij * a_ij)))\n  //     For a transform it looks like:\n  //       Norm(T) = sqrt(s*s + r*r + x*x + r*r + s*s + y*y + 1)\n  //     Thus s and r have bigger impact.\n  //\n  if (typeof epsilon !== 'number') {\n    epsilon = Transform.EPSILON\n  }\n\n  var ds = Math.abs(this.s - t.s)\n  var dr = Math.abs(this.r - t.r)\n  var dx = Math.abs(this.tx - t.tx)\n  var dy = Math.abs(this.ty - t.ty)\n\n  // smaller-or-equal instead of smaller-than to make epsilon=0 work.\n  return ds + dr + dx + dy <= epsilon\n}\n\nproto.equal =\nproto.equals = function (t) {\n  // Are transforms equal?\n  //\n  // Parameters:\n  //   t\n  //     Transform\n  //\n  return (this.s === t.s && this.r === t.r &&\n    this.tx === t.tx && this.ty === t.ty)\n}\n\nproto.getMatrix = function () {\n  // Get the transformation matrix in the format common to\n  // many APIs, including:\n  // - kld-affine\n  //\n  // Return\n  //   object o, having properties a, b, c, d, e, f:\n  //   [ s  -r  tx ]   [ o.a  o.c  o.e ]\n  //   [ r   s  ty ] = [ o.b  o.d  o.f ]\n  //   [ 0   0   1 ]   [  -    -    -  ]\n  return {\n    a: this.s,\n    b: this.r,\n    c: -this.r,\n    d: this.s,\n    e: this.tx,\n    f: this.ty\n  }\n}\n\nproto.getRotation = function () {\n  // in rads\n  return Math.atan2(this.r, this.s)\n}\n\nproto.getScale = function () {\n  // scale multiplier\n  return Math.sqrt(this.r * this.r + this.s * this.s)\n}\n\nproto.getTranslation = function () {\n  // Current translation as a point.\n  return [this.tx, this.ty]\n}\n\nproto.toArray = function () {\n  // Return an array representation of the transformation.\n  //\n  // Together with nudged.createFromArray(...), this method makes an easy\n  // serialization and deserialization to and from JSON possible.\n  return [this.s, this.r, this.tx, this.ty]\n}\n\n// Methods that return new points\n\nproto.transform = function (p) {\n  // p\n  //   point [x, y] or array of points [[x1,y1], [x2, y2], ...]\n\n  if (typeof p[0] === 'number') {\n    // Single point\n    return [\n      this.s * p[0] - this.r * p[1] + this.tx,\n      this.r * p[0] + this.s * p[1] + this.ty\n    ]\n  } // else\n\n  var i\n  var c = []\n  for (i = 0; i < p.length; i += 1) {\n    c.push([\n      this.s * p[i][0] - this.r * p[i][1] + this.tx,\n      this.r * p[i][0] + this.s * p[i][1] + this.ty])\n  }\n  return c\n}\n\n// Methods that return new Transformations\n\nproto.inverse = function () {\n  // Return inversed transform instance\n  // See note 2015-10-26-16-30\n  var det = this.s * this.s + this.r * this.r\n  // Test if singular transformation. These might occur when all the range\n  // points are the same, forcing the scale to drop to zero.\n  if (Math.abs(det) < Transform.EPSILON) {\n    throw new Error('Singular transformations cannot be inversed.')\n  }\n  var shat = this.s / det\n  var rhat = -this.r / det\n  var txhat = (-this.s * this.tx - this.r * this.ty) / det\n  var tyhat = (this.r * this.tx - this.s * this.ty) / det\n\n  return new Transform(shat, rhat, txhat, tyhat)\n}\n\nproto.translateBy = function (dx, dy) {\n  return new Transform(this.s, this.r, this.tx + dx, this.ty + dy)\n}\n\nproto.scaleBy = function (multiplier, pivot) {\n  // Parameter\n  //   multiplier\n  //   pivot\n  //     optional, a [x, y] point\n  var m, x, y\n  m = multiplier // alias\n  if (typeof pivot === 'undefined') {\n    x = y = 0\n  } else {\n    x = pivot[0]\n    y = pivot[1]\n  }\n  return new Transform(\n    m * this.s,\n    m * this.r,\n    m * this.tx + (1 - m) * x,\n    m * this.ty + (1 - m) * y\n  )\n}\n\nproto.rotateBy = function (radians, pivot) {\n  // Parameter\n  //   radians\n  //     from positive x to positive y axis\n  //   pivot\n  //     optional, a [x, y] point\n  //\n  var co, si, x, y, shat, rhat, txhat, tyhat\n  co = Math.cos(radians)\n  si = Math.sin(radians)\n  if (typeof pivot === 'undefined') {\n    x = y = 0\n  } else {\n    x = pivot[0]\n    y = pivot[1]\n  }\n  shat = this.s * co - this.r * si\n  rhat = this.s * si + this.r * co\n  txhat = (this.tx - x) * co - (this.ty - y) * si + x\n  tyhat = (this.tx - x) * si + (this.ty - y) * co + y\n\n  return new Transform(shat, rhat, txhat, tyhat)\n}\n\nproto.multiplyRight =\nproto.multiplyBy = function (transform) {\n  // Multiply this transformation matrix A\n  // from the right with the given transformation matrix B\n  // and return the result AB\n\n  // For reading aid:\n  // s -r tx  t.s -r tx\n  // r  s ty *  r  s ty\n  // 0  0  1    0  0  1\n  var t = transform // alias\n  var shat = this.s * t.s - this.r * t.r\n  var rhat = this.s * t.r + this.r * t.s\n  var txhat = this.s * t.tx - this.r * t.ty + this.tx\n  var tyhat = this.r * t.tx + this.s * t.ty + this.ty\n\n  return new Transform(shat, rhat, txhat, tyhat)\n}\n\nTransform.IDENTITY = new Transform(1, 0, 0, 0)\nTransform.R90 = new Transform(0, 1, 0, 0)\nTransform.R180 = new Transform(-1, 0, 0, 0)\nTransform.R270 = new Transform(0, -1, 0, 0)\nTransform.X2 = new Transform(2, 0, 0, 0)\n\nmodule.exports = Transform\n\n\n//# sourceURL=webpack:///./node_modules/nudged/lib/Transform.js?");

/***/ }),

/***/ "./node_modules/nudged/lib/estimateI.js":
/*!**********************************************!*\
  !*** ./node_modules/nudged/lib/estimateI.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Transform = __webpack_require__(/*! ./Transform */ \"./node_modules/nudged/lib/Transform.js\")\n\nmodule.exports = function () {\n  return Transform.IDENTITY\n}\n\n\n//# sourceURL=webpack:///./node_modules/nudged/lib/estimateI.js?");

/***/ }),

/***/ "./node_modules/nudged/lib/estimateR.js":
/*!**********************************************!*\
  !*** ./node_modules/nudged/lib/estimateR.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Transform = __webpack_require__(/*! ./Transform */ \"./node_modules/nudged/lib/Transform.js\")\n\nmodule.exports = function (domain, range, pivot) {\n  var i, N, D, a0, b0, a, b, c, d, ac, ad, bc, bd, p, q, shat, rhat, tx, ty\n\n  N = Math.min(domain.length, range.length)\n  ac = ad = bc = bd = 0\n\n  if (typeof pivot === 'undefined') {\n    a0 = b0 = 0\n  } else {\n    a0 = pivot[0]\n    b0 = pivot[1]\n  }\n\n  for (i = 0; i < N; i += 1) {\n    a = domain[i][0] - a0\n    b = domain[i][1] - b0\n    c = range[i][0] - a0\n    d = range[i][1] - b0\n    ac += a * c\n    ad += a * d\n    bc += b * c\n    bd += b * d\n  }\n\n  p = ac + bd\n  q = ad - bc\n\n  D = Math.sqrt(p * p + q * q)\n\n  if (D === 0) {\n    // D === 0\n    // <=> q === 0 and p === 0.\n    // <=> ad === bc and ac === -bd\n    // <=> domain in pivot OR range in pivot OR yet unknown cases\n    //     where the angle cannot be determined.\n    // D === 0 also if N === 0.\n    // Assume identity transform to be the best guess\n    return Transform.IDENTITY\n  }\n\n  shat = p / D\n  rhat = q / D\n  tx = a0 - a0 * shat + b0 * rhat\n  ty = b0 - a0 * rhat - b0 * shat\n\n  return new Transform(shat, rhat, tx, ty)\n}\n\n\n//# sourceURL=webpack:///./node_modules/nudged/lib/estimateR.js?");

/***/ }),

/***/ "./node_modules/nudged/lib/estimateS.js":
/*!**********************************************!*\
  !*** ./node_modules/nudged/lib/estimateS.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Transform = __webpack_require__(/*! ./Transform */ \"./node_modules/nudged/lib/Transform.js\")\n\nmodule.exports = function (domain, range, pivot) {\n  var i, N, D, a0, b0, a, b, c, d, ac, bd, aa, bb, shat, tx, ty\n\n  N = Math.min(domain.length, range.length)\n  ac = bd = aa = bb = 0\n\n  if (typeof pivot === 'undefined') {\n    a0 = b0 = 0\n  } else {\n    a0 = pivot[0]\n    b0 = pivot[1]\n  }\n\n  for (i = 0; i < N; i += 1) {\n    a = domain[i][0] - a0\n    b = domain[i][1] - b0\n    c = range[i][0] - a0\n    d = range[i][1] - b0\n    ac += a * c\n    bd += b * d\n    aa += a * a\n    bb += b * b\n  }\n\n  D = aa + bb\n\n  if (D === 0) {\n    // All domain points equal the pivot.\n    // Identity transform is then only solution.\n    // D === 0 also if N === 0.\n    // Assume identity transform to be the best guess\n    return Transform.IDENTITY\n  }\n\n  // Prevent negative scaling because it would be same as positive scaling\n  // and rotation => limit to zero\n  shat = Math.max(0, (ac + bd) / D)\n  tx = (1 - shat) * a0\n  ty = (1 - shat) * b0\n\n  return new Transform(shat, 0, tx, ty)\n}\n\n\n//# sourceURL=webpack:///./node_modules/nudged/lib/estimateS.js?");

/***/ }),

/***/ "./node_modules/nudged/lib/estimateSR.js":
/*!***********************************************!*\
  !*** ./node_modules/nudged/lib/estimateSR.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Transform = __webpack_require__(/*! ./Transform */ \"./node_modules/nudged/lib/Transform.js\")\n\nmodule.exports = function (domain, range, pivot) {\n  // Estimate optimal transformation given the domain and the range\n  // so that the pivot point remains the same.\n  //\n  // Use cases\n  //   - transform an image that has one corner fixed with a pin.\n  //   - allow only scale and rotation by fixing the middle of the object\n  //     to transform.\n  //\n  // Parameters\n  //   domain, an array of [x, y] points\n  //   range, an array of [x, y] points\n  //   pivot, optional\n  //     the point [x, y] that must remain constant in the tranformation.\n  //     Defaults to origo [0, 0]\n  //\n  //\n  var X, Y, N, s, r, tx, ty\n\n  // Optional pivot\n  if (typeof pivot === 'undefined') {\n    pivot = [0, 0]\n  }\n\n  // Alias\n  X = domain\n  Y = range\n\n  // Allow arrays of different length but\n  // ignore the extra points.\n  N = Math.min(X.length, Y.length)\n\n  var v = pivot[0]\n  var w = pivot[1]\n\n  var i, a, b, c, d\n  var a2, b2\n  a2 = b2 = 0\n  var ac, bd, bc, ad\n  ac = bd = bc = ad = 0\n\n  for (i = 0; i < N; i += 1) {\n    a = X[i][0] - v\n    b = X[i][1] - w\n    c = Y[i][0] - v\n    d = Y[i][1] - w\n    a2 += a * a\n    b2 += b * b\n    ac += a * c\n    bd += b * d\n    bc += b * c\n    ad += a * d\n  }\n\n  // Denominator = determinant.\n  // It becomes zero iff N = 0 or X[i] = [v, w] for every i in [0, n).\n  // In other words, iff all the domain points are under the fixed point or\n  // there is no domain points.\n  var den = a2 + b2\n\n  var eps = 0.00000001\n  if (Math.abs(den) < eps) {\n    // The domain points are under the pivot or there is no domain points.\n    // We assume identity transform be the simplest guess. It keeps\n    // the domain points under the pivot if there is some.\n    return new Transform(1, 0, 0, 0)\n  }\n\n  // Estimators\n  s = (ac + bd) / den\n  r = (-bc + ad) / den\n  tx = w * r - v * s + v\n  ty = -v * r - w * s + w\n\n  return new Transform(s, r, tx, ty)\n}\n\n\n//# sourceURL=webpack:///./node_modules/nudged/lib/estimateSR.js?");

/***/ }),

/***/ "./node_modules/nudged/lib/estimateT.js":
/*!**********************************************!*\
  !*** ./node_modules/nudged/lib/estimateT.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Transform = __webpack_require__(/*! ./Transform */ \"./node_modules/nudged/lib/Transform.js\")\n\nmodule.exports = function (domain, range) {\n  var i, N, a1, b1, c1, d1, txhat, tyhat\n\n  N = Math.min(domain.length, range.length)\n  a1 = b1 = c1 = d1 = 0\n\n  if (N < 1) {\n    // Assume identity transform be the best guess\n    return Transform.IDENTITY\n  }\n\n  for (i = 0; i < N; i += 1) {\n    a1 += domain[i][0]\n    b1 += domain[i][1]\n    c1 += range[i][0]\n    d1 += range[i][1]\n  }\n\n  txhat = (c1 - a1) / N\n  tyhat = (d1 - b1) / N\n\n  return new Transform(1, 0, txhat, tyhat)\n}\n\n\n//# sourceURL=webpack:///./node_modules/nudged/lib/estimateT.js?");

/***/ }),

/***/ "./node_modules/nudged/lib/estimateTR.js":
/*!***********************************************!*\
  !*** ./node_modules/nudged/lib/estimateTR.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Transform = __webpack_require__(/*! ./Transform */ \"./node_modules/nudged/lib/Transform.js\")\n\nmodule.exports = function (domain, range) {\n  // Parameters\n  //   domain\n  //     array of [x, y] 2D arrays\n  //   range\n  //     array of [x, y] 2D arrays\n\n  // Alias\n  var X = domain\n  var Y = range\n\n  // Allow arrays of different length but\n  // ignore the extra points.\n  var N = Math.min(X.length, Y.length)\n\n  var i, a, b, c, d, a1, b1, c1, d1, ac, ad, bc, bd\n  a1 = b1 = c1 = d1 = ac = ad = bc = bd = 0\n  for (i = 0; i < N; i += 1) {\n    a = X[i][0]\n    b = X[i][1]\n    c = Y[i][0]\n    d = Y[i][1]\n    a1 += a\n    b1 += b\n    c1 += c\n    d1 += d\n    ac += a * c\n    ad += a * d\n    bc += b * c\n    bd += b * d\n  }\n\n  // Denominator.\n  var v = N * (ad - bc) - a1 * d1 + b1 * c1\n  var w = N * (ac + bd) - a1 * c1 - b1 * d1\n  var D = Math.sqrt(v * v + w * w)\n\n  var eps = 0.00000001\n  if (D < eps) {\n    // N === 0 => D === 0\n    if (N === 0) {\n      return new Transform(1, 0, 0, 0)\n    } // else\n    // D === 0 <=> undecidable\n    // We guess the translation to the mean of the range to be the best guess.\n    // Here a, b represents the mean of domain points.\n    return new Transform(1, 0, (c1 - a1) / N, (d1 - b1) / N)\n  }\n\n  // Estimators\n  var shat = w / D\n  var rhat = v / D\n  var txhat = (-a1 * shat + b1 * rhat + c1) / N\n  var tyhat = (-a1 * rhat - b1 * shat + d1) / N\n\n  return new Transform(shat, rhat, txhat, tyhat)\n}\n\n\n//# sourceURL=webpack:///./node_modules/nudged/lib/estimateTR.js?");

/***/ }),

/***/ "./node_modules/nudged/lib/estimateTS.js":
/*!***********************************************!*\
  !*** ./node_modules/nudged/lib/estimateTS.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Transform = __webpack_require__(/*! ./Transform */ \"./node_modules/nudged/lib/Transform.js\")\n\nmodule.exports = function (domain, range) {\n  // Parameters\n  //   domain\n  //     array of [x, y] 2D arrays\n  //   range\n  //     array of [x, y] 2D arrays\n\n  // Alias\n  var X = domain\n  var Y = range\n\n  // Allow arrays of different length but\n  // ignore the extra points.\n  var N = Math.min(X.length, Y.length)\n\n  var i, a, b, c, d, a1, b1, c1, d1, a2, b2, ac, bd\n  a1 = b1 = c1 = d1 = a2 = b2 = ac = bd = 0\n  for (i = 0; i < N; i += 1) {\n    a = X[i][0]\n    b = X[i][1]\n    c = Y[i][0]\n    d = Y[i][1]\n    a1 += a\n    b1 += b\n    c1 += c\n    d1 += d\n    a2 += a * a\n    b2 += b * b\n    ac += a * c\n    bd += b * d\n  }\n\n  // Denominator.\n  var N2 = N * N\n  var a12 = a1 * a1\n  var b12 = b1 * b1\n  var p = a2 + b2\n  var q = ac + bd\n  var D = N2 * p - N * (a12 + b12)\n\n  var eps = 0.00000001\n  if (D < eps) {\n    // N === 0 => D === 0\n    if (N === 0) {\n      return new Transform(1, 0, 0, 0)\n    } // else\n    // D === 0 <=> all the domain points are the same\n    // We guess the translation to the mean of the range to be the best guess.\n    // Here a, b represents the mean of domain points.\n    return new Transform(1, 0, (c1 / N) - a, (d1 / N) - b)\n  }\n\n  // Estimators\n  var shat = (N2 * q - N * (a1 * c1 + b1 * d1)) / D\n  var txhat = (-N * a1 * q + N * c1 * p - b12 * c1 + a1 * b1 * d1) / D\n  var tyhat = (-N * b1 * q + N * d1 * p - a12 * d1 + a1 * b1 * c1) / D\n\n  return new Transform(shat, 0, txhat, tyhat)\n}\n\n\n//# sourceURL=webpack:///./node_modules/nudged/lib/estimateTS.js?");

/***/ }),

/***/ "./node_modules/nudged/lib/estimateTSR.js":
/*!************************************************!*\
  !*** ./node_modules/nudged/lib/estimateTSR.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Transform = __webpack_require__(/*! ./Transform */ \"./node_modules/nudged/lib/Transform.js\")\n\nmodule.exports = function (domain, range) {\n  // Parameters\n  //   domain\n  //     array of [x, y] 2D arrays\n  //   range\n  //     array of [x, y] 2D arrays\n  var X, Y, N, s, r, tx, ty\n\n  // Alias\n  X = domain\n  Y = range\n\n  // Allow arrays of different length but\n  // ignore the extra points.\n  N = Math.min(X.length, Y.length)\n\n  // If length is zero, no estimation can be done. We choose the indentity\n  // transformation be the best quess.\n  if (N === 0) {\n    return new Transform(1, 0, 0, 0)\n  } // else\n\n  var i, a, b, c, d\n  var a1 = 0\n  var b1 = 0\n  var c1 = 0\n  var d1 = 0\n  var a2 = 0\n  var b2 = 0\n  var ad = 0\n  var bc = 0\n  var ac = 0\n  var bd = 0\n  for (i = 0; i < N; i += 1) {\n    a = X[i][0]\n    b = X[i][1]\n    c = Y[i][0]\n    d = Y[i][1]\n    a1 += a\n    b1 += b\n    c1 += c\n    d1 += d\n    a2 += a * a\n    b2 += b * b\n    ad += a * d\n    bc += b * c\n    ac += a * c\n    bd += b * d\n  }\n\n  // Denominator.\n  // It is zero iff X[i] = X[j] for every i and j in [0, n).\n  // In other words, iff all the domain points are the same or there is only one domain point.\n  var den = N * a2 + N * b2 - a1 * a1 - b1 * b1\n\n  var eps = 0.00000001\n  if (-eps < den && den < eps) {\n    // The domain points are the same.\n    // We guess the translation to the mean of the range to be the best guess.\n    // Here a, b represents the mean of domain points.\n    return new Transform(1, 0, (c1 / N) - a, (d1 / N) - b)\n  }\n\n  // Estimators\n  s = (N * (ac + bd) - a1 * c1 - b1 * d1) / den\n  r = (N * (ad - bc) + b1 * c1 - a1 * d1) / den\n  tx = (-a1 * (ac + bd) + b1 * (ad - bc) + a2 * c1 + b2 * c1) / den\n  ty = (-b1 * (ac + bd) - a1 * (ad - bc) + a2 * d1 + b2 * d1) / den\n\n  return new Transform(s, r, tx, ty)\n}\n\n\n//# sourceURL=webpack:///./node_modules/nudged/lib/estimateTSR.js?");

/***/ }),

/***/ "./node_modules/nudged/lib/version.js":
/*!********************************************!*\
  !*** ./node_modules/nudged/lib/version.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// generated by genversion\nmodule.exports = '1.4.0'\n\n\n//# sourceURL=webpack:///./node_modules/nudged/lib/version.js?");

/***/ }),

/***/ "./node_modules/robust-orientation/orientation.js":
/*!********************************************************!*\
  !*** ./node_modules/robust-orientation/orientation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar twoProduct = __webpack_require__(/*! two-product */ \"./node_modules/two-product/two-product.js\")\nvar robustSum = __webpack_require__(/*! robust-sum */ \"./node_modules/robust-sum/robust-sum.js\")\nvar robustScale = __webpack_require__(/*! robust-scale */ \"./node_modules/robust-scale/robust-scale.js\")\nvar robustSubtract = __webpack_require__(/*! robust-subtract */ \"./node_modules/robust-subtract/robust-diff.js\")\n\nvar NUM_EXPAND = 5\n\nvar EPSILON     = 1.1102230246251565e-16\nvar ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON\nvar ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON\n\nfunction cofactor(m, c) {\n  var result = new Array(m.length-1)\n  for(var i=1; i<m.length; ++i) {\n    var r = result[i-1] = new Array(m.length-1)\n    for(var j=0,k=0; j<m.length; ++j) {\n      if(j === c) {\n        continue\n      }\n      r[k++] = m[i][j]\n    }\n  }\n  return result\n}\n\nfunction matrix(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = new Array(n)\n    for(var j=0; j<n; ++j) {\n      result[i][j] = [\"m\", j, \"[\", (n-i-1), \"]\"].join(\"\")\n    }\n  }\n  return result\n}\n\nfunction sign(n) {\n  if(n & 1) {\n    return \"-\"\n  }\n  return \"\"\n}\n\nfunction generateSum(expr) {\n  if(expr.length === 1) {\n    return expr[0]\n  } else if(expr.length === 2) {\n    return [\"sum(\", expr[0], \",\", expr[1], \")\"].join(\"\")\n  } else {\n    var m = expr.length>>1\n    return [\"sum(\", generateSum(expr.slice(0, m)), \",\", generateSum(expr.slice(m)), \")\"].join(\"\")\n  }\n}\n\nfunction determinant(m) {\n  if(m.length === 2) {\n    return [[\"sum(prod(\", m[0][0], \",\", m[1][1], \"),prod(-\", m[0][1], \",\", m[1][0], \"))\"].join(\"\")]\n  } else {\n    var expr = []\n    for(var i=0; i<m.length; ++i) {\n      expr.push([\"scale(\", generateSum(determinant(cofactor(m, i))), \",\", sign(i), m[0][i], \")\"].join(\"\"))\n    }\n    return expr\n  }\n}\n\nfunction orientation(n) {\n  var pos = []\n  var neg = []\n  var m = matrix(n)\n  var args = []\n  for(var i=0; i<n; ++i) {\n    if((i&1)===0) {\n      pos.push.apply(pos, determinant(cofactor(m, i)))\n    } else {\n      neg.push.apply(neg, determinant(cofactor(m, i)))\n    }\n    args.push(\"m\" + i)\n  }\n  var posExpr = generateSum(pos)\n  var negExpr = generateSum(neg)\n  var funcName = \"orientation\" + n + \"Exact\"\n  var code = [\"function \", funcName, \"(\", args.join(), \"){var p=\", posExpr, \",n=\", negExpr, \",d=sub(p,n);\\\nreturn d[d.length-1];};return \", funcName].join(\"\")\n  var proc = new Function(\"sum\", \"prod\", \"scale\", \"sub\", code)\n  return proc(robustSum, twoProduct, robustScale, robustSubtract)\n}\n\nvar orientation3Exact = orientation(3)\nvar orientation4Exact = orientation(4)\n\nvar CACHED = [\n  function orientation0() { return 0 },\n  function orientation1() { return 0 },\n  function orientation2(a, b) { \n    return b[0] - a[0]\n  },\n  function orientation3(a, b, c) {\n    var l = (a[1] - c[1]) * (b[0] - c[0])\n    var r = (a[0] - c[0]) * (b[1] - c[1])\n    var det = l - r\n    var s\n    if(l > 0) {\n      if(r <= 0) {\n        return det\n      } else {\n        s = l + r\n      }\n    } else if(l < 0) {\n      if(r >= 0) {\n        return det\n      } else {\n        s = -(l + r)\n      }\n    } else {\n      return det\n    }\n    var tol = ERRBOUND3 * s\n    if(det >= tol || det <= -tol) {\n      return det\n    }\n    return orientation3Exact(a, b, c)\n  },\n  function orientation4(a,b,c,d) {\n    var adx = a[0] - d[0]\n    var bdx = b[0] - d[0]\n    var cdx = c[0] - d[0]\n    var ady = a[1] - d[1]\n    var bdy = b[1] - d[1]\n    var cdy = c[1] - d[1]\n    var adz = a[2] - d[2]\n    var bdz = b[2] - d[2]\n    var cdz = c[2] - d[2]\n    var bdxcdy = bdx * cdy\n    var cdxbdy = cdx * bdy\n    var cdxady = cdx * ady\n    var adxcdy = adx * cdy\n    var adxbdy = adx * bdy\n    var bdxady = bdx * ady\n    var det = adz * (bdxcdy - cdxbdy) \n            + bdz * (cdxady - adxcdy)\n            + cdz * (adxbdy - bdxady)\n    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)\n                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)\n                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)\n    var tol = ERRBOUND4 * permanent\n    if ((det > tol) || (-det > tol)) {\n      return det\n    }\n    return orientation4Exact(a,b,c,d)\n  }\n]\n\nfunction slowOrient(args) {\n  var proc = CACHED[args.length]\n  if(!proc) {\n    proc = CACHED[args.length] = orientation(args.length)\n  }\n  return proc.apply(undefined, args)\n}\n\nfunction generateOrientationProc() {\n  while(CACHED.length <= NUM_EXPAND) {\n    CACHED.push(orientation(CACHED.length))\n  }\n  var args = []\n  var procArgs = [\"slow\"]\n  for(var i=0; i<=NUM_EXPAND; ++i) {\n    args.push(\"a\" + i)\n    procArgs.push(\"o\" + i)\n  }\n  var code = [\n    \"function getOrientation(\", args.join(), \"){switch(arguments.length){case 0:case 1:return 0;\"\n  ]\n  for(var i=2; i<=NUM_EXPAND; ++i) {\n    code.push(\"case \", i, \":return o\", i, \"(\", args.slice(0, i).join(), \");\")\n  }\n  code.push(\"}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation\")\n  procArgs.push(code.join(\"\"))\n\n  var proc = Function.apply(undefined, procArgs)\n  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))\n  for(var i=0; i<=NUM_EXPAND; ++i) {\n    module.exports[i] = CACHED[i]\n  }\n}\n\ngenerateOrientationProc()\n\n//# sourceURL=webpack:///./node_modules/robust-orientation/orientation.js?");

/***/ }),

/***/ "./node_modules/robust-scale/robust-scale.js":
/*!***************************************************!*\
  !*** ./node_modules/robust-scale/robust-scale.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar twoProduct = __webpack_require__(/*! two-product */ \"./node_modules/two-product/two-product.js\")\nvar twoSum = __webpack_require__(/*! two-sum */ \"./node_modules/two-sum/two-sum.js\")\n\nmodule.exports = scaleLinearExpansion\n\nfunction scaleLinearExpansion(e, scale) {\n  var n = e.length\n  if(n === 1) {\n    var ts = twoProduct(e[0], scale)\n    if(ts[0]) {\n      return ts\n    }\n    return [ ts[1] ]\n  }\n  var g = new Array(2 * n)\n  var q = [0.1, 0.1]\n  var t = [0.1, 0.1]\n  var count = 0\n  twoProduct(e[0], scale, q)\n  if(q[0]) {\n    g[count++] = q[0]\n  }\n  for(var i=1; i<n; ++i) {\n    twoProduct(e[i], scale, t)\n    var pq = q[1]\n    twoSum(pq, t[0], q)\n    if(q[0]) {\n      g[count++] = q[0]\n    }\n    var a = t[1]\n    var b = q[1]\n    var x = a + b\n    var bv = x - a\n    var y = b - bv\n    q[1] = x\n    if(y) {\n      g[count++] = y\n    }\n  }\n  if(q[1]) {\n    g[count++] = q[1]\n  }\n  if(count === 0) {\n    g[count++] = 0.0\n  }\n  g.length = count\n  return g\n}\n\n//# sourceURL=webpack:///./node_modules/robust-scale/robust-scale.js?");

/***/ }),

/***/ "./node_modules/robust-subtract/robust-diff.js":
/*!*****************************************************!*\
  !*** ./node_modules/robust-subtract/robust-diff.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = robustSubtract\n\n//Easy case: Add two scalars\nfunction scalarScalar(a, b) {\n  var x = a + b\n  var bv = x - a\n  var av = x - bv\n  var br = b - bv\n  var ar = a - av\n  var y = ar + br\n  if(y) {\n    return [y, x]\n  }\n  return [x]\n}\n\nfunction robustSubtract(e, f) {\n  var ne = e.length|0\n  var nf = f.length|0\n  if(ne === 1 && nf === 1) {\n    return scalarScalar(e[0], -f[0])\n  }\n  var n = ne + nf\n  var g = new Array(n)\n  var count = 0\n  var eptr = 0\n  var fptr = 0\n  var abs = Math.abs\n  var ei = e[eptr]\n  var ea = abs(ei)\n  var fi = -f[fptr]\n  var fa = abs(fi)\n  var a, b\n  if(ea < fa) {\n    b = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    b = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n      fa = abs(fi)\n    }\n  }\n  if((eptr < ne && ea < fa) || (fptr >= nf)) {\n    a = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    a = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n      fa = abs(fi)\n    }\n  }\n  var x = a + b\n  var bv = x - a\n  var y = b - bv\n  var q0 = y\n  var q1 = x\n  var _x, _bv, _av, _br, _ar\n  while(eptr < ne && fptr < nf) {\n    if(ea < fa) {\n      a = ei\n      eptr += 1\n      if(eptr < ne) {\n        ei = e[eptr]\n        ea = abs(ei)\n      }\n    } else {\n      a = fi\n      fptr += 1\n      if(fptr < nf) {\n        fi = -f[fptr]\n        fa = abs(fi)\n      }\n    }\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n  }\n  while(eptr < ne) {\n    a = ei\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n    }\n  }\n  while(fptr < nf) {\n    a = fi\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    } \n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n    }\n  }\n  if(q0) {\n    g[count++] = q0\n  }\n  if(q1) {\n    g[count++] = q1\n  }\n  if(!count) {\n    g[count++] = 0.0  \n  }\n  g.length = count\n  return g\n}\n\n//# sourceURL=webpack:///./node_modules/robust-subtract/robust-diff.js?");

/***/ }),

/***/ "./node_modules/robust-sum/robust-sum.js":
/*!***********************************************!*\
  !*** ./node_modules/robust-sum/robust-sum.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = linearExpansionSum\n\n//Easy case: Add two scalars\nfunction scalarScalar(a, b) {\n  var x = a + b\n  var bv = x - a\n  var av = x - bv\n  var br = b - bv\n  var ar = a - av\n  var y = ar + br\n  if(y) {\n    return [y, x]\n  }\n  return [x]\n}\n\nfunction linearExpansionSum(e, f) {\n  var ne = e.length|0\n  var nf = f.length|0\n  if(ne === 1 && nf === 1) {\n    return scalarScalar(e[0], f[0])\n  }\n  var n = ne + nf\n  var g = new Array(n)\n  var count = 0\n  var eptr = 0\n  var fptr = 0\n  var abs = Math.abs\n  var ei = e[eptr]\n  var ea = abs(ei)\n  var fi = f[fptr]\n  var fa = abs(fi)\n  var a, b\n  if(ea < fa) {\n    b = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    b = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n      fa = abs(fi)\n    }\n  }\n  if((eptr < ne && ea < fa) || (fptr >= nf)) {\n    a = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    a = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n      fa = abs(fi)\n    }\n  }\n  var x = a + b\n  var bv = x - a\n  var y = b - bv\n  var q0 = y\n  var q1 = x\n  var _x, _bv, _av, _br, _ar\n  while(eptr < ne && fptr < nf) {\n    if(ea < fa) {\n      a = ei\n      eptr += 1\n      if(eptr < ne) {\n        ei = e[eptr]\n        ea = abs(ei)\n      }\n    } else {\n      a = fi\n      fptr += 1\n      if(fptr < nf) {\n        fi = f[fptr]\n        fa = abs(fi)\n      }\n    }\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n  }\n  while(eptr < ne) {\n    a = ei\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n    }\n  }\n  while(fptr < nf) {\n    a = fi\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    } \n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n    }\n  }\n  if(q0) {\n    g[count++] = q0\n  }\n  if(q1) {\n    g[count++] = q1\n  }\n  if(!count) {\n    g[count++] = 0.0  \n  }\n  g.length = count\n  return g\n}\n\n//# sourceURL=webpack:///./node_modules/robust-sum/robust-sum.js?");

/***/ }),

/***/ "./node_modules/seqid/seqid.js":
/*!*************************************!*\
  !*** ./node_modules/seqid/seqid.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = SeqId\n\nfunction SeqId(initial) {\n  if (!(this instanceof SeqId)) {\n    return new SeqId(initial)\n  }\n  if (initial == null) {\n    initial = (Math.random() - 0.5) * Math.pow(2, 32)\n  }\n  this._id = initial | 0\n}\nSeqId.prototype.next = function () {\n  this._id = (this._id + 1) | 0\n  return this._id\n}\n\n\n//# sourceURL=webpack:///./node_modules/seqid/seqid.js?");

/***/ }),

/***/ "./node_modules/tapspace/index.js":
/*!****************************************!*\
  !*** ./node_modules/tapspace/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// API v4\n\nexports.geom = __webpack_require__(/*! ./lib/geom */ \"./node_modules/tapspace/lib/geom/index.js\")\nexports.Space = __webpack_require__(/*! ./lib/Space */ \"./node_modules/tapspace/lib/Space.js\")\nexports.SpaceGroup = __webpack_require__(/*! ./lib/SpaceGroup */ \"./node_modules/tapspace/lib/SpaceGroup.js\")\nexports.SpaceHTML = __webpack_require__(/*! ./lib/SpaceHTML */ \"./node_modules/tapspace/lib/SpaceHTML.js\")\nexports.SpaceImage = __webpack_require__(/*! ./lib/SpaceImage */ \"./node_modules/tapspace/lib/SpaceImage.js\")\nexports.SpacePixel = __webpack_require__(/*! ./lib/SpacePixel */ \"./node_modules/tapspace/lib/SpacePixel.js\")\nexports.SpaceView = __webpack_require__(/*! ./lib/SpaceView */ \"./node_modules/tapspace/lib/SpaceView/index.js\")\nexports.Touchable = __webpack_require__(/*! ./lib/Touchable */ \"./node_modules/tapspace/lib/Touchable/index.js\")\nexports.Wheelable = __webpack_require__(/*! ./lib/Wheelable */ \"./node_modules/tapspace/lib/Wheelable/index.js\")\n// Maybe in future:\n// exports.SpacePoint = require('./lib/SpacePoint')\n// exports.SpaceTransform = require('./lib/SpaceTransform')\n\nexports.preload = __webpack_require__(/*! loadimages */ \"./node_modules/loadimages/index.js\")\nexports.version = __webpack_require__(/*! ./lib/version */ \"./node_modules/tapspace/lib/version.js\")\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/index.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/AbstractNode.js":
/*!***************************************************!*\
  !*** ./node_modules/tapspace/lib/AbstractNode.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// AbstractNode\n//\n// Emits\n//   childAdded\n//     after a descendant has been added\n//   childRemoved\n//     after a descendant has been removed\n//   added\n//     after added to new parent\n//   removed\n//     after detached from parent\n//\n// 2018-01-18\n// Changes to 2017-12-00 dev decision.\n//\n//   Events about child node addition or removal are no longer emitted\n//   by all ancestors. The parent of the new node is the only one to\n//   emit childAdded and childRemoved. The new refactored SpaceView\n//   listens the elements directly instead of the root, Space. Therefore\n//   the bubbling of childAdded and childRemoved events is no longer\n//   needed.\n//\n// 2017-12-00\n// Dev decision about listening events:\n//\n//   Do not listen externally accessible events internally.\n//   Use recursive function calls instead.\n//   There is a couple of reasons for this.\n//   First, chains of event handlers are somewhat hard to debug.\n//   It gets harder when an event has multiple handlers.\n//   Second, the execution order of external and internal handlers\n//   is unspecified. If same events are listened both internally and\n//   externally, execution-order related bugs will happen and\n//   those are very hard to debug.\n//\n//   Example:\n//     The node emits 'removed' after being detached from parent.\n//     In v3, the parent listened for this event and handled it\n//     by emitting 'childRemoved'. The parent also listened\n//     the child's 'childRemoved' and handled it by echoing.\n//     The goal was to let SpaceViews react to removals by\n//     just listening to Space. This caused a bug in setParent\n//     with non-trivial node hierarchy. Debugging it required\n//     following complex event chains and there were suprising\n//     handlers along the way. The bug was impossible to find.\n//\n\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\")\nvar extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\")\n// Unique ID generator. Unique over session.\n// Usage: seqid.next()\n// Return: int\nvar seqid = __webpack_require__(/*! seqid */ \"./node_modules/seqid/seqid.js\")(0)\n\nvar AbstractNode = function () {\n  Emitter.call(this)\n\n  // Each node has an id. That is used by the parent nodes and in views.\n  this.id = seqid.next().toString()\n\n  // Nodes with null parent are root nodes i.e. spaces.\n  // AbstractNode#remove sets _parent to null.\n  this._parent = null\n\n  // Keep track on node siblings in two-way linked list manner.\n  this._prevSibling = null\n  this._nextSibling = null\n\n  // Dict because good key search time complexity\n  this._children = {}\n  // List for children order\n  this._order = []\n}\n\nvar p = extend({}, Emitter.prototype)\nAbstractNode.prototype = p\n\np.addChild = function (child, i) {\n  // Add the given AbstractNode as a child and remove it from its old parent.\n  child.setParent(this, i)\n\n  return this\n}\n\np.bringAbove = function (sibling) {\n  // Remove this node from the old parent and add to a new parent so that\n  // the given node becomes the next sibling of the node.\n  //\n  if (sibling.isRoot()) {\n    throw new Error('Cannot send after a root node.')\n  }\n\n  var newParent = sibling._parent\n  var index = newParent._order.indexOf(sibling)\n\n  // Index is off by 1 if same parent and the item is moved toward back.\n  // Smaller or EQUAL to is needed to ensure correct position if indices equal.\n  var oldParent = this._parent\n  if (oldParent === newParent) {\n    if (oldParent._order.indexOf(this) <= index) {\n      index = index - 1\n    }\n  }\n\n  this.setParent(sibling._parent, index + 1)\n}\n\np.bringToFront = function () {\n  // Remove this node and reinsert it as the last child.\n  //\n  if (this.isRoot()) {\n    // Already back\n    return\n  }\n\n  var index = this._parent._order.length\n  this.setParent(this._parent, index)\n}\n\np.getAncestors = function () {\n  // Return an array of AbstractNodes, _parent at [0], _parent._parent at [1],\n  // and so on.\n  //\n  var pa = this._parent\n  var ancs = []\n\n  while (pa !== null) {\n    ancs.push(pa)\n    pa = pa._parent\n  }\n\n  return ancs\n}\n\np.getChildren = function () {\n  // Return child AbstractNodes in a list.\n  // Does not include the children of the children.\n  //\n  // Return\n  //   Array\n  //\n  return this._order.slice() // copy\n}\n\np.getDescendants = function () {\n  // All descendants in a list, including the children.\n  //\n  var i, children, child, arr\n  arr = []\n  children = this.getChildren()\n  for (i = 0; i < children.length; i += 1) {\n    child = children[i]\n    arr = arr.concat(child, child.getDescendants())\n  }\n  return arr\n}\n\np.getFirstChild = function () {\n  if (this._order.length < 1) {\n    return null\n  }\n\n  return this._order[0]\n}\n\np.getLastChild = function () {\n  if (this._order.length < 1) {\n    return null\n  }\n\n  return this._order[this._order.length - 1]\n}\n\np.getNextSibling = function () {\n  return this._nextSibling\n}\n\np.getParent = function () {\n  return this._parent\n}\n\np.getPreviousSibling = function () {\n  return this._prevSibling\n}\n\np.getRootParent = function () {\n  // Get the predecessor without parents in recursive manner.\n  if (this._parent === null) {\n    return this\n  } // else\n  return this._parent.getRootParent()\n}\n\np.hasChild = function (abstractNode) {\n  // Return\n  //   true if abstractNode is a child of this.\n  return abstractNode._parent === this\n}\n\np.hasDescendant = function (abstractNode) {\n  // Return\n  //   true if abstractNode is a descendant of this.\n  //\n  var p = abstractNode._parent\n  while (p !== null && p !== this) {\n    p = p._parent\n  }\n  if (p === null) {\n    return false\n  } // else\n  return true\n}\n\np.isRoot = function () {\n  return this._parent === null\n}\n\np.remove = function () {\n  // Remove this space node from its parent.\n  // Return: see setParent\n  return this.setParent(null)\n}\n\np.sendBelow = function (sibling) {\n  // Remove this node from the old parent and add to a new parent so that\n  // the given node becomes the next sibling of the node.\n  //\n  if (sibling.isRoot()) {\n    throw new Error('Cannot bring before a root node.')\n  }\n\n  var newParent = sibling._parent\n  var index = newParent._order.indexOf(sibling)\n\n  // Index is off by 1 if same parent and the item is moved toward back.\n  var oldParent = this._parent\n  if (oldParent === newParent) {\n    if (oldParent._order.indexOf(this) < index) {\n      index = index - 1\n    }\n  }\n\n  this.setParent(sibling._parent, index)\n}\n\np.sendToBack = function () {\n  // Remove this node and reinsert it as the first child.\n  //\n  if (this.isRoot()) {\n    // Already first\n    return\n  }\n\n  this.setParent(this._parent, 0)\n}\n\np.setParent = function (newParent, index) {\n  // Add node to new parent. Will be removed from old parent.\n  // Optional index defines the new position among siblings.\n  //\n  // Parameters:\n  //   newParent\n  //     an AbstractNode\n  //   index\n  //     integer, optional, default to last index. Index of 0 will\n  //     insert the node as the first child.\n  //\n  // Emits:\n  //   removed, after node is removed from old parent\n  //   added, after node is added to new parent\n  //\n  // Causes emits:\n  //   oldParent emits childRemoved after node is removed\n  //   newParent emits childAdded after node is added\n  //\n  //\n  // Dev note about cyclic relationship detection:\n  //   A\n  //   |\n  //  / \\\n  // B   C\n  //\n  // Different cases. The emitter relationship status changes...\n  //   from root to root:\n  //     no worries about cyclic structures\n  //   from root to child:\n  //     If the new parent is a descendant of the emitter, problems.\n  //     If the new parent the emitter itself, problems.\n  //   from child to root:\n  //     Loses parenthood. No cyclic worries.\n  //   from child to child:\n  //     If the new parent is a descendant of the emitter, problems.\n  //     If the new parent the emitter itself, problems.\n  // If new parent has the emitter as descendant already...\n  //   then no worries because emitter would only create a new branch.\n  //\n\n  if (typeof newParent === 'undefined') {\n    throw new Error('Parameter \\'newParent\\' is required.')\n  }\n\n  if (typeof index === 'undefined' && newParent !== null) {\n    index = newParent._order.length\n  }\n\n  var oldParent = this._parent\n\n  if (oldParent === null) {\n    if (newParent === null) {\n      // AbstractNode's position changed from root to root.\n      // Do nothing\n    } else {\n      // From root to child.\n      // Add only.\n\n      // Prevent cycles.\n      if (this === newParent || this.hasDescendant(newParent)) {\n        throw new Error('Cyclic parent-child relationships are forbidden.')\n      }\n\n      newParent._addChild(this, index)\n\n      this.emit('added', {\n        source: this,\n        newParent: newParent,\n        oldParent: null\n      })\n      newParent.emit('childAdded', {\n        source: newParent,\n        newChild: this,\n        oldParent: null\n      })\n    }\n  } else {\n    if (newParent === null) {\n      // From child to root.\n      // Remove only.\n\n      oldParent._removeChild(this)\n\n      this.emit('removed', {\n        source: this,\n        newParent: null,\n        oldParent: oldParent\n      })\n      oldParent.emit('childRemoved', {\n        source: oldParent,\n        oldChild: this,\n        newParent: null\n      })\n    } else {\n      // From child to child.\n      // Remove and add.\n\n      // Prevent cycles.\n      if (this === newParent || this.hasDescendant(newParent)) {\n        throw new Error('Cyclic parent-child relationships are forbidden.')\n      }\n\n      oldParent._removeChild(this)\n      newParent._addChild(this, index)\n\n      // With both oldParent and newParent, SpaceView is able to\n      // decide whether to keep same HTMLElement or recreate it.\n      this.emit('removed', {\n        source: this,\n        newParent: newParent,\n        oldParent: oldParent\n      })\n      oldParent.emit('childRemoved', {\n        source: oldParent,\n        oldChild: this,\n        newParent: newParent\n      })\n      this.emit('added', {\n        source: this,\n        newParent: newParent,\n        oldParent: oldParent\n      })\n      newParent.emit('childAdded', {\n        source: newParent,\n        newChild: this,\n        oldParent: oldParent\n      })\n    }\n  }\n}\n\np._addChild = function (abstractNode, index) {\n  // To be called from abstractNode.setParent().\n  // If called from anywhere else, ensure cyclic relationships are detected.\n  var n = abstractNode\n  var prev = this._order[index - 1]\n  var next = this._order[index]\n\n  n._parent = this\n\n  if (prev) {\n    n._prevSibling = prev\n    prev._nextSibling = n\n  } else {\n    n._prevSibling = null\n  }\n\n  if (next) {\n    n._nextSibling = next\n    next._prevSibling = n\n  } else {\n    n._nextSibling = null\n  }\n\n  this._children[n.id] = n\n  this._order.splice(index, 0, n)\n}\n\np._removeChild = function (abstractNode) {\n  // To be called from abstractNode.setParent().\n  // Precondition: abstractNode is a child of this\n  var n = abstractNode\n  var prev = n._prevSibling\n  var next = n._nextSibling\n\n  n._parent = null\n  n._prevSibling = null\n  n._nextSibling = null\n\n  if (prev) {\n    prev._nextSibling = next // null next is ok\n  }\n  if (next) {\n    next._prevSibling = prev // null prev is ok\n  }\n\n  delete this._children[n.id]\n  this._order.splice(this._order.indexOf(n), 1)\n}\n\nmodule.exports = AbstractNode\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/AbstractNode.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/AbstractPlane.js":
/*!****************************************************!*\
  !*** ./node_modules/tapspace/lib/AbstractPlane.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// AbstractPlane\n//\n// A AbstractPlane represents a coordinate system. It includes\n// methods to transform the system.\n//\n// Note: In v3 and in alpha stages of v4 there was\n//   AbstractPlane and SpaceTransformer that were then\n//   merged together to form the new AbstractPlane.\n//   The initial reason for this was to have an abstract\n//   prototype for the non-transformable Space. However,\n//   it is simpler to override transforming methods in\n//   Space than have an extra abstract prototype.\n//\nvar ITransform = __webpack_require__(/*! ./geom/ITransform */ \"./node_modules/tapspace/lib/geom/ITransform.js\")\nvar IVector = __webpack_require__(/*! ./geom/IVector */ \"./node_modules/tapspace/lib/geom/IVector.js\")\nvar Vector = __webpack_require__(/*! ./geom/Vector */ \"./node_modules/tapspace/lib/geom/Vector.js\")\nvar Transform = __webpack_require__(/*! ./geom/Transform */ \"./node_modules/tapspace/lib/geom/Transform.js\")\nvar AbstractNode = __webpack_require__(/*! ./AbstractNode */ \"./node_modules/tapspace/lib/AbstractNode.js\")\nvar extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\")\n\nvar AbstractPlane = function () {\n  // A coordinate plane in space\n  //\n  AbstractNode.call(this)\n\n  // Coordinate transformation.\n  // The transformation from the plane to the parent (space).\n  // See 2016-03-05-09\n  //\n  // Let:\n  //   x_space, a point in space\n  //   x_plane, a point on the plane.\n  //   T, the coordinate transformation of the plane\n  // Then:\n  //   x_space = T * x_plane\n  //\n  // For Space, it is obviously the identity transform:\n  //   x_space = T * x_space\n  this._T = Transform.IDENTITY // identity transformation\n\n  this.on('removed', function (ev) {\n    // Ensure that a root node has only a identity transformation.\n    // However, if the plane was removed just to move it onto a new parent,\n    // preserve the local transformation.\n    //\n    // Dev. notes:\n    //   Should we maintain global location?\n    //   Why? To make it easy to attach to view temporarily.\n    //   On the other hand, same relative location would be convenient\n    //   when moving subelements from group to another.\n    //   Would it be easier to do explicitly:\n    //     gt = item.getGlobalTransform()\n    //     item.setParent(foo)\n    //     item.setGlobalTransform(gt)\n    //   Yes it would. Therefore, do not maintain global location!\n\n    if (ev.newParent === null) {\n      // Root nodes cannot be moved.\n      //\n      // Previously .resetTransform call was used but it unnecessarily\n      // emitted 'transformed' event.\n      ev.source._T = Transform.IDENTITY\n    } else {\n      // Assert: removed from null parent?\n      if (ev.oldParent === null) {\n        throw new Error('Could not be removed from null parent')\n      }\n    }\n  })\n}\n\nvar p = extend({}, AbstractNode.prototype)\nAbstractPlane.prototype = p\n\np.at = function (x, y) {\n  // Get a IVector at the (x, y) on the plane. Alternatively,\n  // takes in a Vector.\n  //\n  // Parameters\n  //   x\n  //     Number\n  //   y\n  //     Number\n  // OR\n  //   vec\n  //     Vector\n  //\n  // Return\n  //   IVector\n  //\n  if (typeof x === 'object' && typeof y === 'undefined') {\n    // x is Vector\n    return new IVector(x, this)\n  }\n\n  if (typeof x !== 'number' && typeof y !== 'number') {\n    // DEBUG TODO remove the check\n    throw new Error('Invalid Vector')\n  }\n\n  return new IVector(new Vector(x, y), this)\n}\n\np.getGlobalTransform = function () {\n  // Get a transformation from the plane to the space as Transform.\n  //\n  // Return:\n  //   Transform\n  //     Transformation from the plane to root i.e. space.\n  //\n  // Dev note:\n  //   Local transformations go like:\n  //     xy_parent = T_plane * xy_plane\n  //     xy_parent_parent = T_parent * xy_parent\n  //     ...\n  //     xy_root = T_parent_parent..._parent * xy_parent_parent..._parent\n  //   Therefore global transformation is:\n  //     xy_root = T_parent_..._parent * ... * T_parent * T_plane * xy_plane\n  //\n  var T, plane\n\n  T = Transform.IDENTITY\n  plane = this\n\n  // As long as the plane is not root\n  while (plane._parent !== null) {\n    T = plane._T.multiplyRight(T)\n    plane = plane._parent\n  }\n\n  // plane._parent === null, hence plane is the root.\n  return T\n}\n\np.getGlobalITransform = function () {\n  // Get a transformation from the plane to the space as ITransform.\n  //\n  // Return:\n  //   ITransform\n  //     Transformation from the plane to root i.e. space.\n  //\n  var T, plane\n\n  T = Transform.IDENTITY\n  plane = this\n\n  // As long as the plane is not root\n  while (plane._parent !== null) {\n    T = plane._T.multiplyRight(T)\n    plane = plane._parent\n  }\n\n  // plane._parent === null, hence plane is the root.\n  return new ITransform(T)\n}\n\np.getLocalTransform = function () {\n  // Local coordinate transform from plane to parent.\n  //\n  // Return\n  //   Transform\n  //\n  // Note:\n  //   returns transformation from plane to parent, i.e.\n  //     xy_parent = T * xy_plane\n  //\n  // Design decision about the transform reference plane\n  //   The returned ITransform contains the Transform from the plane\n  //   to its parent without any regard on the global effect of the transform.\n  //   For example\n  //   a local translation of 10 screen pixels\n  //   on a 100x upscaled plane\n  //   yields an ITransform that translates 0.1 screen pixels\n  //   on the Space plane.\n  //   An alternative option was that the effect stays same.\n  //   E.g. the ITransform still translates 10 screen pixels\n  //   on the Space plane. This option was then implemented by\n  //   getGlobalLocalTransform.\n  //\n  // This method is needed for example if we want to store\n  // space item's local position for later use. In the following\n  // example, a SpacePixel is moved at the same position with another.\n  //   let px, py be SpacePixel instances\n  //     that have been moved differently but have same parent.\n  //   var lt = px.getLocalTransform()\n  //   py.setLocalTransform(lt)\n  //   Now px and py are positioned similarly.\n  //\n  // Old notes from v3:\n  //   An alternative would have been to graft to the parent's coords:\n  //     return new SpaceTransform(this._parent, this._T);\n  //   This is kind of equivalent because:\n  //     this_T_on_plane = this_T * this_T * inv(this_T) = this_T\n  //   However, it is more natural if getLocalTransform is represented on\n  //   the local coord system.\n  //\n  return this._T\n}\n\np.getLocalITransform = function () {\n  // Get the local transformation from the plane to the parent\n  // so that its global effect is captured. For example,\n  // if the local translation is a translation of 10 units,\n  // and the parent is a 100x scaled plane, then\n  // the effect of the translation is 1000 units on the space.\n  // This method preserves this effect unlike getLocalTransform\n  // that loses the plane context.\n  //\n  if (this._parent === null) {\n    return ITransform.IDENTITY\n  }\n  return new ITransform(this._T, this._parent)\n}\n\np.resetTransform = function () {\n  // Reset transform to identity.\n  //\n  return this.setLocalTransform(Transform.IDENTITY)\n}\n\np.setGlobalTransform = function (tr) {\n  // Set local transform so that the global transform of the plane becomes\n  // equal to the given Transform.\n  //\n  // Dev note:\n  //   Let T be coord. transf. from the plane to root (space).\n  //   So is this._T.\n  //   current_glob_trans = parent_glob_trans * this_T\n  //\n  //   new_glob_trans = parent_glob_trans * X\n  //   <=> X = inv(parent_glob_trans) * new_glob_trans\n  //\n  var pgt, newT\n\n  if (this._parent === null) {\n    pgt = this._T // identity\n  } else {\n    // pgt is mapping from the plane to space.\n    pgt = this._parent.getGlobalTransform()\n  }\n\n  newT = pgt.inverse().multiplyBy(tr)\n  return this.setLocalTransform(newT)\n}\n\np.setGlobalITransform = function (itr) {\n  // Set local transform so that the global transform of the plane becomes\n  // equal to the given ITransform. For example, let T be 2x scaling\n  // and P a SpacePixel on a 100x upscaled plane. Then P.setGlobalITransform(T)\n  // updates P's local transform to 0.02x scaling.\n  //\n  return this.setGlobalTransform(itr.toSpace())\n}\n\np.setLocalTransform = function (tr) {\n  // Set the transformation of the plane, relative to its parent.\n  // If the ancestors together cause 100x scaling and the given transform\n  // represents 0.01x scaling, the global transformation becomes the identity.\n  //\n  // If you want the equal global\n  // effect regardless the ancestors, use setLocalITransform.\n  //\n  // This method is needed when we whan to restore stored position,\n  // maybe after modification.\n  //\n  // Parameters:\n  //   tr\n  //     Transform\n  //\n\n  // If we are root, cannot set.\n  if (this._parent === null) {\n    throw new Error('Root nodes cannot be transformed.')\n  }\n\n  var oldT = this._T\n  this._T = tr\n\n  // Emit with how much the transformation changed\n  this.emit('transformed', {\n    source: this,\n    newTransform: this._T,\n    oldTransform: oldT\n  })\n\n  return this\n}\n\np.setLocalITransform = function (itr) {\n  // Set the transformation of the plane so that the global effect of\n  // the transform stays the same regardless of the ancestors.\n  // For example, if you have multiple planes with different ancestors, but\n  // want the planes to be visually double in size, you can call\n  // setLocalITransform with 2x scaling for each plane.\n  //\n  // Parameters:\n  //   itr\n  //     ITransform\n  //\n  // Returns:\n  //   this\n  //     Because chainable\n  //\n  var newT = itr.to(this._parent)\n  return this.setLocalTransform(newT)\n}\n\np.snap = function (pivot, igrid) {\n  // Snap the plane to the given IGrid at pivot\n  //\n  // Parameters\n  //   pivot\n  //     IVector\n  //   igrid\n  //     IGrid\n  //\n  // Emits\n  //   transformed\n  //\n  // Return\n  //   this\n  //\n  // Dev. note\n  //   The same can be done with IGrid with:\n  //   var itr =  new ITransform(this._T, this._parent)\n  //   this._T = igrid.snap(pivot, itr).to(this._parent)\n  //\n\n  var newT = igrid.to(this._parent).snap(pivot.to(this), this._T)\n\n  return this.setLocalTransform(newT)\n}\n\np.transformBy = function (itr, plane) {\n  // Apply an Transform or ITransform to the node's local transform.\n  // By default, itr is first represented on the parent's coordinate plane.\n  // If you want to apply the effect the itr has on another plane,\n  // you can specify the plane.\n  //\n  // Parameters:\n  //   itr\n  //     Transform or ITransform.\n  //   plane\n  //     Optional AbstractPlane. Default to the parent plane. Provide if\n  //     you want to apply the effect the itr has on a plane\n  //     different from the parent. Null equals space.\n  //\n  // Emits:\n  //   transformed\n  //\n  // Return:\n  //   this\n  //     To make chainable\n  //\n  if (typeof plane === 'undefined') {\n    plane = this._parent\n  }\n\n  // Convert ITransform to Transform.\n  // If already Transform, leave as it is.\n  if (itr.hasOwnProperty('_tr')) {\n    itr = itr.to(plane)\n  }\n\n  return this.setLocalTransform(itr.multiplyRight(this._T))\n}\n\np.translate = function (domain, range) {\n  // Move plane horizontally and vertically by example.\n  //\n  // Translate the plane so that after the translation, the domain points\n  // would be as close to given range points as possible.\n  //\n  // Parameters: see ITransform.prototype.translate\n  var st = ITransform.estimate('T', domain, range)\n  return this.transformBy(st)\n}\n\np.scale = function (pivot, multiplierOrDomain, range) {\n  // Parameters: see ITransform.prototype.scale\n  var st = ITransform.IDENTITY.scale(pivot, multiplierOrDomain, range)\n  return this.transformBy(st)\n}\n\np.rotate = function (pivot, radiansOrDomain, range) {\n  // Parameters: see ITransform.prototype.rotate\n  var st = ITransform.IDENTITY.rotate(pivot, radiansOrDomain, range)\n  return this.transformBy(st)\n}\n\np.translateScale = function (domain, range) {\n  // Parameters: see ITransform.prototype.translateScale\n  var st = ITransform.estimate('TS', domain, range)\n  return this.transformBy(st)\n}\n\np.translateRotate = function (domain, range) {\n  // Parameters: see ITransform.prototype.translateRotate\n  var st = ITransform.estimate('TR', domain, range)\n  return this.transformBy(st)\n}\n\np.scaleRotate = function (pivot, domain, range) {\n  // Parameters: see ITransform.prototype.scaleRotate\n  var st = ITransform.estimate('SR', domain, range, pivot)\n  return this.transformBy(st)\n}\n\np.translateScaleRotate = function (domain, range) {\n  // Parameters: see ITransform.prototype.translateScaleRotate\n  var st = ITransform.estimate('TSR', domain, range)\n  return this.transformBy(st)\n}\n\nmodule.exports = AbstractPlane\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/AbstractPlane.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/AbstractRectangle.js":
/*!********************************************************!*\
  !*** ./node_modules/tapspace/lib/AbstractRectangle.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar IVector = __webpack_require__(/*! ./geom/IVector */ \"./node_modules/tapspace/lib/geom/IVector.js\")\nvar Vector = __webpack_require__(/*! ./geom/Vector */ \"./node_modules/tapspace/lib/geom/Vector.js\")\nvar ISize = __webpack_require__(/*! ./geom/ISize */ \"./node_modules/tapspace/lib/geom/ISize.js\")\nvar Size = __webpack_require__(/*! ./geom/Size */ \"./node_modules/tapspace/lib/geom/Size.js\")\nvar IPath = __webpack_require__(/*! ./geom/IPath */ \"./node_modules/tapspace/lib/geom/IPath.js\")\nvar Path = __webpack_require__(/*! ./geom/Path */ \"./node_modules/tapspace/lib/geom/Path.js\")\nvar AbstractPlane = __webpack_require__(/*! ./AbstractPlane */ \"./node_modules/tapspace/lib/AbstractPlane.js\")\nvar extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\")\n\nvar AbstractRectangle = function () {\n  // A rectangular area in space.\n  //\n  AbstractPlane.call(this)\n\n  // Rectangles have size.\n  // By default transformation, width 1 and height 1 equal to 1 space unit.\n  this._size = new Size(1, 1)\n}\n\nvar p = extend({}, AbstractPlane.prototype)\nAbstractRectangle.prototype = p\n\np.atNorm = function (x, y) {\n  // Return an IVector by coordinates normalized about the size.\n  // atNorm(1, 0) returns the point at the right upper corner.\n  //\n  if (typeof y !== 'number') {\n    // Helps to detect bugs, especially as the interface has changed in v4\n    throw new Error('Invalid (x, y) coordinates. Numbers are required.')\n  }\n\n  return new IVector(\n    new Vector(this._size.width * x, this._size.height * y),\n    this\n  )\n}\n\np.atMid = function () {\n  var mid = new Vector(this._size.width / 2, this._size.height / 2)\n  return new IVector(mid, this)\n}\n\np.atMidN = function () {\n  return new IVector(new Vector(this._size.width / 2, 0), this)\n}\n\np.atMidW = function () {\n  return new IVector(new Vector(0, this._size.height / 2), this)\n}\n\np.atMidE = function () {\n  return new IVector(new Vector(this._size.width, this._size.height / 2), this)\n}\n\np.atMidS = function () {\n  return new IVector(new Vector(this._size.width / 2, this._size.height), this)\n}\n\np.atNW = function () {\n  return new IVector(new Vector(0, 0), this)\n}\n\np.atNE = function () {\n  return new IVector(new Vector(this._size.width, 0), this)\n}\n\np.atSW = function () {\n  return new IVector(new Vector(0, this._size.height), this)\n}\n\np.atSE = function () {\n  return new IVector(new Vector(this._size.width, this._size.height), this)\n}\n\np.fitScale = function (ipa) {\n  // Scale and translate to fit around ipa.\n  //\n  // Parameters:\n  //   ipa\n  //     IPath, AbstractRectangle, or SpaceGroup\n  //\n  // Emits:\n  //   transformed\n  //\n  // Return\n  //   self\n  //     for chaining\n  //\n\n  // Rectangular paths\n  var selfBounds = this.getHull().to(this).getBounds()\n  var ipaBounds = ipa.getHull().to(this).getBounds()\n  // The goal is to scale and translate self so that\n  // the ipa is entirely inside self but still maximal in size.\n  // We could just take selfBounds as the domain and ipaBounds as the range\n  // and then translateScale(domain, range) but that leads to a correct\n  // solution only when the width-height ratios are equal. Otherwise\n  // the translateScale estimation leaves self too small.\n  //\n  // A more general solution is achieved by making a custom domain\n  // by picking such points along selfBounds that form a width-height ratio\n  // equal to ipaBounds.\n  var ihh, hh, iwh, wh, domain, idomain, irange\n  var w = selfBounds.get(2).x - selfBounds.get(0).x\n  var h = selfBounds.get(2).y - selfBounds.get(0).y\n  var iw = ipaBounds.get(2).x - ipaBounds.get(0).x\n  var ih = ipaBounds.get(2).y - ipaBounds.get(0).y\n  var r = w / h // TODO h=0\n  var ir = iw / ih // TODO ih=0\n\n  if (ir > r) {\n    // Ipa has wider shape than self.\n    // Thus in the result the widths are equal.\n    //        w\n    // A +---------+ B         +     +\n    //   |         |           | hh  |\n    // A'+---------+ B' +      +     |\n    //   |   ipa   |    | ihh        | h\n    // D'+---------+ C' +      +     |\n    //   |         |           | hh  |\n    // D +---------+ C         +     +\n    ihh = w / ir // TODO ir=0\n    hh = (h / 2) - (ihh / 2)\n    // We have everything we need for a squeezed domain\n    domain = new Path([\n      new Vector(selfBounds.get(0).x, selfBounds.get(0).y + hh), // A'\n      new Vector(selfBounds.get(1).x, selfBounds.get(1).y - hh), // D'\n      new Vector(selfBounds.get(2).x, selfBounds.get(2).y - hh), // C'\n      new Vector(selfBounds.get(3).x, selfBounds.get(3).y + hh) // B'\n    ])\n  } else {\n    // Self has wider shape than ipa.\n    // Thus in the result the heights are equal.\n    //        A'  B'\n    // A +----+---+----+ B  +\n    //   |    |   |    |    |\n    //   |    |ipa|    |    | h\n    //   |    |   |    |    |\n    // D +----+---+----+ C  +\n    //        D'  C'\n    //\n    //        +---+      iwh\n    //   +----+          wh\n    //            +----+ wh\n    //   +-------------+ w\n    iwh = h * ir\n    wh = (w / 2) - (iwh / 2)\n    domain = new Path([\n      new Vector(selfBounds.get(0).x + wh, selfBounds.get(0).y), // A'\n      new Vector(selfBounds.get(1).x + wh, selfBounds.get(1).y), // D'\n      new Vector(selfBounds.get(2).x - wh, selfBounds.get(2).y), // C'\n      new Vector(selfBounds.get(3).x - wh, selfBounds.get(3).y) // B'\n    ])\n  }\n\n  idomain = new IPath(domain, this)\n  irange = new IPath(ipaBounds, this)\n  return this.translateScale(idomain, irange)\n}\n\np.fitSize = function (ipa) {\n  // Resize and translate to fit around ipa without altering\n  // the scale of the plane. The size aspect ratio of the rectangle\n  // may change.\n  // The algorithm goes as follows:\n  // 1. represent the path in the coordinate system of the resizable self\n  // 2. take bounding box of the path\n  // 3. resize self to match the size of the bounding box\n  // 4. translate self to match the location of the bounding box\n  // As a result, the rectangle's area covers the given path.\n  //\n  // Parameters:\n  //   ipa\n  //     IPath, AbstractRectangle, or SpaceGroup\n  //\n  // Emits:\n  //   transformed\n  //   resized\n  //\n  // Return:\n  //   self\n  //     for chaining\n  //\n  var ipaBounds = ipa.getHull().to(this).getBounds()\n  // Compute size and resize\n  var nw = ipaBounds.get(0) // Vector\n  var se = ipaBounds.get(2)\n  var w = se.x - nw.x\n  var h = se.y - nw.y\n\n  var oldSize = this._size\n  this._size = new Size(w, h)\n\n  // Translate to center\n  this.translate(this.atNW(), new IVector(nw, this))\n\n  this.emit('resized', {\n    source: this,\n    newSize: this._size,\n    oldSize: oldSize\n  })\n\n  return this\n}\n\np.getHull = function () {\n  // Get bounding IPath\n  //\n  // 0--3\n  // |  |\n  // 1--2\n  //\n  return new IPath(new Path([\n    new Vector(0, 0),\n    new Vector(0, this._size.height),\n    new Vector(this._size.width, this._size.height),\n    new Vector(this._size.width, 0)\n  ]), this)\n}\n\np.getSize = function () {\n  // Get size as Size\n  return this._size\n}\n\np.getISize = function () {\n  // Get size as ISize\n  return new ISize(this._size, this)\n}\n\np.setSize = function (sizeOrWidth, height) {\n  // Set size of the rectangle in units of its own plane.\n  //\n  // Parameter\n  //   diagonal\n  //     Vector(width, height)\n  //\n  var oldSize = this._size\n\n  if (typeof sizeOrWidth === 'object') {\n    this._size = sizeOrWidth\n  } else if (typeof sizeOrWidth === 'number' && typeof height === 'number') {\n    this._size = new Size(sizeOrWidth, height)\n  } else {\n    throw new Error('Invalid size parameters')\n  }\n\n  this.emit('resized', {\n    source: this,\n    newSize: this._size,\n    oldSize: oldSize\n  })\n\n  return this\n}\n\np.setISize = function (isize) {\n  // Set rectangle dimensions in plane-invariant manner.\n  // ISize takes care of\n  // required coordinate transformations. Handy if you want\n  // two rectangles to have globally equal size.\n  //\n  // Parameter\n  //   isize\n  //     ISize\n  //\n  var oldSize = this._size\n  this._size = isize.to(this)\n\n  this.emit('resized', {\n    source: this,\n    newSize: this._size,\n    oldSize: oldSize\n  })\n\n  return this\n}\n\nmodule.exports = AbstractRectangle\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/AbstractRectangle.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/Space.js":
/*!********************************************!*\
  !*** ./node_modules/tapspace/lib/Space.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// Space. The root item.\n//\nvar Path = __webpack_require__(/*! ./geom/Path */ \"./node_modules/tapspace/lib/geom/Path.js\")\nvar Vector = __webpack_require__(/*! ./geom/Vector */ \"./node_modules/tapspace/lib/geom/Vector.js\")\nvar IPath = __webpack_require__(/*! ./geom/IPath */ \"./node_modules/tapspace/lib/geom/IPath.js\")\nvar AbstractPlane = __webpack_require__(/*! ./AbstractPlane */ \"./node_modules/tapspace/lib/AbstractPlane.js\")\nvar extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\")\n\nvar Space = function () {\n  AbstractPlane.call(this)\n  // Space has constant identity transformation _T\n}\n\nvar p = extend({}, AbstractPlane.prototype)\nSpace.prototype = p\n\np.atMid = function () {\n  // Get a Vector to the centroid of the bounding convex hull.\n  // Rather computationally intensive.\n  return this.getHull().atMid()\n}\n\np.setParent = function () {\n  // Remove possibility to add to parent.\n  throw new Error('Space cannot have a parent.')\n}\n\np.remove = function () {\n  // Silent, already removed. Otherwise would throw the error in setParent\n}\n\np.getHull = function () {\n  // Get bounding box as an IPath. Equals the convex hull\n  // of the children. Iterates over all children AbstractNodes so keep\n  // an eye on efficiency.\n  //\n  // Return\n  //   IPath\n  //     If no children, returns a path with single point at origin.\n  //\n\n  var children = this.getChildren()\n\n  if (children.length < 1) {\n    return new IPath(new Path([new Vector(0, 0)]), this)\n  }\n\n  var ip = children.reduce(function (acc, child) {\n    return acc.add(child.getHull())\n  }, new IPath())\n\n  return ip.getHull()\n}\n\nmodule.exports = Space\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/Space.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/SpaceGroup.js":
/*!*************************************************!*\
  !*** ./node_modules/tapspace/lib/SpaceGroup.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// SpaceGroup\n// A group of objects in space.\n// The group should not have any representation in views.\n//\nvar Space = __webpack_require__(/*! ./Space */ \"./node_modules/tapspace/lib/Space.js\")\nvar AbstractPlane = __webpack_require__(/*! ./AbstractPlane */ \"./node_modules/tapspace/lib/AbstractPlane.js\")\nvar extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\")\n\nvar SpaceGroup = function (parent) {\n  // A set of AbstractPlanes.\n  //\n  // Parameters:\n  //   parent\n  //     a AbstractNode\n  //\n  AbstractPlane.call(this)\n\n  if (typeof parent === 'object') {\n    this.setParent(parent)\n  }\n}\n\nvar p = extend({}, AbstractPlane.prototype)\nSpaceGroup.prototype = p\n\n// Copy from Space\np.atMid = Space.prototype.atMid\np.getHull = Space.prototype.getHull\n\np.copy = function () {\n  // Return a deep copy of the SpaceGroup.\n  // All the descendants are copied.\n  //\n  var g = new SpaceGroup()\n\n  this.getChildren().forEach(function (child) {\n    var c = child.copy()\n    var t = child.getLocalTransform()\n    c.setParent(g)\n    c.setLocalTransform(t)\n  })\n\n  return g\n}\n\nmodule.exports = SpaceGroup\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/SpaceGroup.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/SpaceHTML.js":
/*!************************************************!*\
  !*** ./node_modules/tapspace/lib/SpaceHTML.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// SpaceElement\n//\n// A HTMLElement [1] in the space.\n//\n// [1] https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\n//\nvar AbstractRectangle = __webpack_require__(/*! ./AbstractRectangle */ \"./node_modules/tapspace/lib/AbstractRectangle.js\")\nvar extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\")\n\nvar SpaceHTML = function (html, parent) {\n  // Parameters\n  //   html\n  //     a string, containing html\n  //   parent\n  //     a AbstractNode, optional, default to null\n  //\n  AbstractRectangle.call(this)\n\n  this.html = html\n  this.setSize(256, 256) // Initial element size.\n\n  if (typeof parent === 'object') {\n    this.setParent(parent)\n  }\n}\n\nvar p = extend({}, AbstractRectangle.prototype)\nSpaceHTML.prototype = p\n\np.copy = function () {\n  // Return a copy of the SpaceHTML.\n  // The copy has similar HTML content and size but no parent.\n  //\n  var h = new SpaceHTML(this.html)\n  h.setSize(this.getSize())\n  return h\n}\n\np.getHTML = function () {\n  return this.html\n}\n\nmodule.exports = SpaceHTML\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/SpaceHTML.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/SpaceImage.js":
/*!*************************************************!*\
  !*** ./node_modules/tapspace/lib/SpaceImage.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global HTMLImageElement, Image */\n//\n// SpaceImage\n//\nvar AbstractRectangle = __webpack_require__(/*! ./AbstractRectangle */ \"./node_modules/tapspace/lib/AbstractRectangle.js\")\nvar extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\")\n\nvar SpaceImage = function (img, parent) {\n  // Parameters:\n  //   img\n  //     a preloaded HTMLImageElement or an image literal (see below).\n  //   parent\n  //     a AbstractNode, optional, default to null\n  //\n  // Image literal:\n  //   {\n  //     src: <string>\n  //     width: <int>\n  //     height: <int>\n  //   }\n  //\n  if (typeof img !== 'object') {\n    throw new Error('Invalid image')\n  }\n  AbstractRectangle.call(this)\n\n  if (img instanceof HTMLImageElement) {\n    this.image = img\n  } else {\n    // Image literal.\n    this.image = new Image(img.width, img.height)\n    this.image.src = img.src\n  }\n\n  this.setSize(img.width, img.height) // Size of the rectangle\n\n  if (typeof parent === 'object') {\n    this.setParent(parent)\n  }\n}\n\nSpaceImage.prototype = extend({}, AbstractRectangle.prototype)\n\nSpaceImage.prototype.copy = function () {\n  // Return a copy of the SpaceImage.\n  // The copy has the same image and size but is not attached to a parent.\n  //\n  var si = new SpaceImage(this.image)\n  si.setSize(this.getSize())\n  return si\n}\n\nSpaceImage.prototype.getImage = function () {\n  return this.image\n}\n\nmodule.exports = SpaceImage\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/SpaceImage.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/SpacePixel.js":
/*!*************************************************!*\
  !*** ./node_modules/tapspace/lib/SpacePixel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// SpacePixel\n// A simple rectangular object in space with size 1x1\n// Created for testing purposes.\n//\nvar AbstractRectangle = __webpack_require__(/*! ./AbstractRectangle */ \"./node_modules/tapspace/lib/AbstractRectangle.js\")\nvar extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\")\n\nvar SpacePixel = function (color, parent) {\n  // A 1x1 rectangle\n  //\n  // Parameters:\n  //   color\n  //     CSS color string. Optional, default '#000000'\n  //   parent\n  //     a AbstractNode, optional, default to null\n  //\n  AbstractRectangle.call(this)\n\n  this.color = (typeof color === 'string' ? color : '#000000')\n  this.setSize(1, 1)\n\n  if (typeof parent === 'object') {\n    this.setParent(parent)\n  }\n}\n\nSpacePixel.prototype = extend({}, AbstractRectangle.prototype)\n\nSpacePixel.prototype.copy = function () {\n  // Return a copy of the SpacePixel.\n  // The copy has the same color and size but is not attached to a parent.\n  //\n  var px = new SpacePixel(this.color)\n  px.setSize(this.getSize())\n  return px\n}\n\nSpacePixel.prototype.getColor = function () {\n  return this.color\n}\n\nmodule.exports = SpacePixel\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/SpacePixel.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/SpaceView/createElementFor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tapspace/lib/SpaceView/createElementFor.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar Space = __webpack_require__(/*! ../Space */ \"./node_modules/tapspace/lib/Space.js\")\nvar SpaceGroup = __webpack_require__(/*! ../SpaceGroup */ \"./node_modules/tapspace/lib/SpaceGroup.js\")\nvar SpaceHTML = __webpack_require__(/*! ../SpaceHTML */ \"./node_modules/tapspace/lib/SpaceHTML.js\")\nvar SpaceImage = __webpack_require__(/*! ../SpaceImage */ \"./node_modules/tapspace/lib/SpaceImage.js\")\nvar SpacePixel = __webpack_require__(/*! ../SpacePixel */ \"./node_modules/tapspace/lib/SpacePixel.js\")\n\nmodule.exports = function (abstractNode, SpaceView) {\n  // Build a HTMLElement for the given space node.\n  // The HTMLElement is not added to DOM.\n  //\n  // Parameters\n  //   abstractNode\n  //     a AbstractNode\n  //   SpaceView\n  //     to avoid circular dependency, the constructor\n  //     of SpaceView must be provided here.\n  //     Otherwise createElementFor requires SpaceView and vice versa.\n  var el, wh\n  var n = abstractNode // alias\n\n  if (n instanceof SpaceImage) {\n    // SpaceImage\n    el = n.image.cloneNode() // probably efficient\n    el.className = 'tapspace-image'\n  } else if (n instanceof SpaceHTML) {\n    // SpaceHTML\n    el = document.createElement('div') // container\n    el.innerHTML = n.html\n    el.className = 'tapspace-html'\n  } else if (n instanceof SpacePixel) {\n    // SpacePixel\n    el = document.createElement('div')\n    el.className = 'tapspace-pixel'\n    el.style.backgroundColor = n.color // pixel color\n  } else if (n instanceof SpaceView) {\n    // SpaceView will have only a zero-size container for its children.\n    // This way touch events are not catched by the view but by the space\n    // container.\n    // The default overflow: visible will allow the children\n    // to be rendered outside the zero.\n    el = document.createElement('div')\n    el.className = 'tapspace-view'\n    el.style.width = '0px'\n    el.style.height = '0px'\n    el.style.display = 'inline-block'\n    el.style.position = 'absolute'\n    el.style.transformOrigin = '0 0'\n    return el\n  } else if (n instanceof SpaceGroup) {\n    el = document.createElement('div')\n    el.className = 'tapspace-group'\n    el.style.width = '0px'\n    el.style.height = '0px'\n    el.style.display = 'inline-block'\n    el.style.position = 'absolute'\n    el.style.transformOrigin = '0 0'\n    return el\n  } else if (n instanceof Space) {\n    el = document.createElement('div')\n    el.className = 'tapspace-space'\n    el.style.width = '0px'\n    el.style.height = '0px'\n    el.style.display = 'inline-block'\n    el.style.position = 'absolute'\n    el.style.transformOrigin = '0 0'\n    return el\n  } else {\n    throw new Error('Unknown AbstractNode subtype; cannot represent')\n  }\n\n  // Common styles for AbstractRectangle instances\n  // -- Resize\n  wh = n.getSize()\n  el.style.width = wh.width + 'px'\n  el.style.height = wh.height + 'px'\n  // -- Positioning. Absolute position allows elements to overlap\n  //    before and during transforms.\n  el.style.display = 'inline-block'\n  el.style.position = 'absolute'\n  // -- The default transform-origin is at the middle of the image.\n  //    That would mess up the top-left based coordinate system.\n  el.style.transformOrigin = '0 0'\n\n  return el\n}\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/SpaceView/createElementFor.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/SpaceView/index.js":
/*!******************************************************!*\
  !*** ./node_modules/tapspace/lib/SpaceView/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// A View into Space, implemented in HTML DOM and CSS\n// This module gives a starting point for implementing\n// views in other tech such as Canvas or WebGL\n//\n// Notes:\n//\n// [1]\n// View has handler for 'added' event.\n// View's target space has handler for 'childAdded' event.\n// When a view is parented on a space, the two handlers cause\n// duplicate rendering of the view's AbstractNode.\n// To go in details, calling _renderElementFor for the space\n// attaches 'childAdded' handler to the space. The handler\n// will be fired after execution of the view's 'added'\n// handler because the view has been just added as a child\n// of the space. To prevent a double call of _renderElementFor\n// for the view, the 'childAdded' handler of the space must\n// check if the added child is a view or not. If it is the view,\n// then there is no need to render it because the view is\n// already rendered by the view's 'added' handler.\n//\n// [2]\n// Compute the size of the view directly from DOM\n// because detecting viewport resize is difficult.\n// https://github.com/taataa/tapspace/issues/55\n//\nvar createElementFor = __webpack_require__(/*! ./createElementFor */ \"./node_modules/tapspace/lib/SpaceView/createElementFor.js\")\nvar setElementTransform = __webpack_require__(/*! ./setElementTransform */ \"./node_modules/tapspace/lib/SpaceView/setElementTransform.js\")\nvar AbstractRectangle = __webpack_require__(/*! ../AbstractRectangle */ \"./node_modules/tapspace/lib/AbstractRectangle.js\")\nvar Space = __webpack_require__(/*! ../Space */ \"./node_modules/tapspace/lib/Space.js\")\nvar extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\")\n\nvar DOM_SPACENODE_PROPERTY = '_tapspace_node'\n\n// Constructor\n\nvar SpaceView = function (space) {\n  // Parameters\n  //   space\n  //     a Space, optional, default to null.\n\n  AbstractRectangle.call(this)\n\n  // This is the DOM container. Populated in mount().\n  this._el = null\n\n  // Mapping from AbstractNode#id to HTMLElement\n  // Every HTMLElement created by the view is stored here.\n  this._elements = {}\n  // Mapping from AbstractNode#id to a map from an event name to a handler fn.\n  // Event handlers of every rendered AbstractNode are stored here.\n  this._handlers = {}\n  // Mapping from an event name to a handler fn.\n  // Handlers for the view's events like 'added'. Populated in mount().\n  this._viewHandlers = {}\n\n  // View is now ready to be added onto the space.\n  // Note that this implicitly sets\n  //   this._parent = space\n  // Therefore, to access the space, call this.getParent() or this._parent\n\n  if (typeof space === 'object') {\n    // Test if valid space\n    if (!(space instanceof Space)) {\n      throw new Error('Parent of a View must be a Space.')\n    }\n    this.setParent(space)\n  }\n}\n\n// Prototype mixin\n\nvar p = extend({}, AbstractRectangle.prototype)\nSpaceView.prototype = p\n\n// Public methods\n\np.fitScale = function (ipath) {\n  // Overwrite AbstractRectangle#fitScale() to throw an error\n  // when the view is not yet mounted and thus has no proper\n  // dimensions with to fit.\n  //\n  if (!this.isMounted()) {\n    throw new Error('View is not yet mounted and thus has no proper size ' +\n      'for fitting. Call mount() before fitScale().')\n  }\n\n  return AbstractRectangle.prototype.fitScale.call(this, ipath)\n}\n\np.fitSize = function () {\n  // Override AbstractRectangle#fitSize\n  throw new Error('Use refreshSize to resize the view and fitScale to fit.')\n}\n\np.getElementBySpaceItem = function (abstractNode) {\n  // Get HTML element representation of the space node.\n  // Return null if not found.\n\n  var n = this._elements[abstractNode.id]\n\n  // n will be undefined if not found.\n  if (n) {\n    return n\n  }\n  return null\n}\n\np.getContainer = function () {\n  // Return the DOM root element of the space view.\n  // Return null if not yet mounted.\n  return this._el\n}\n\np.getSpaceItemByElementId = function (id) {\n  // Get AbstractNode by HTML element id\n  // Return null if no node for such id.\n  var el = document.getElementById(id)\n\n  if (el && el.hasOwnProperty(DOM_SPACENODE_PROPERTY)) {\n    return el[DOM_SPACENODE_PROPERTY]\n  }\n\n  return null\n}\n\np.isMounted = function () {\n  return this._el !== null\n}\n\np.mount = function (htmlContainer) {\n  // Begin to use htmlContainer as the DOM root for the space.\n  //\n  // Design decision:\n  //   In v3 the HTML container was provided via the constructor.\n  //   This led to a poor coding style where 'new SpaceView'\n  //   was called just for its rendering side-effect. In v4\n  //   we wanted the side-effect to be more explicit and made\n  //   it a separate method 'mount'.\n  //\n\n  // Test if valid dom element\n  if (!(htmlContainer && 'tagName' in htmlContainer)) {\n    throw new Error('Container should be a DOM Element')\n  }\n\n  // If same container, no reason to do anything\n  if (this._el === htmlContainer) {\n    return\n  }\n\n  // Clear the old container\n  this.unmount()\n  this._el = htmlContainer\n\n  // Init style.\n  // Note:\n  // \"position: relative\" is needed to enable \"overflow: hidden\".\n  // Without \"overflow: hidden\", if transformed elements get outside\n  // the initial viewport, Chrome on Android increases\n  // the dimensions of the document.\n  this._el.style.position = 'relative'\n  this._el.style.overflow = 'hidden'\n  this._el.style.display = 'block'\n\n  // Init size in space.\n  this._setSize(this._el.clientWidth, this._el.clientHeight)\n\n  // Render the space.\n  // Note that this renders also an element for the SpaceView,\n  // although the element will be 0x0 and meant for the children of the view.\n  // It is possible that the view is mounted before parented.\n  if (this._parent) {\n    this._renderElementFor(this._parent)\n  }\n\n  // A HTMLElement was rendered for the space itself.\n  // This element is a bit special, because it should not react\n  // to transformations of the Space (how could it, Space does not transform)\n  // but to transformations of the SpaceView.\n\n  var view = this\n  this._viewHandlers = {\n    added: function () {\n      // If the view becomes attached to a new parent,\n      // render the content of the new parent.\n      // See [1] for interaction with the 'childAdded' handler of the parent.\n      view._renderElementFor(view._parent)\n    },\n    transformed: function () {\n      // View becomes transformed.\n      // => inverse transform HTMLElement of the Space\n      //   => Browser retransforms HTMLElements of the descendants.\n      // =>\n      var el, vel, tr, vtr\n      el = view._elements[view._parent.id]\n      vel = view._elements[view.id]\n      tr = view._T.inverse()\n      vtr = view._T\n\n      setElementTransform(el, tr)\n      // This undoes the transformation for the view's children\n      setElementTransform(vel, vtr)\n    }\n  }\n\n  this.on('added', this._viewHandlers.added)\n  this.on('transformed', this._viewHandlers.transformed)\n}\n\nvar setParentSuperProto = p.setParent\np.setParent = function (newParent) {\n  // Override the AbstractNode#setParent so that only a Space\n  // is allowed to become the parent of a SpaceView.\n  if (!(newParent instanceof Space)) {\n    throw new Error('A View can only be a child of a Space')\n  }\n\n  // Remove elements of the oldParent if the parent is about to change.\n  // It is easier to remove the elements before _parent changes. That\n  // would be the case if removal happens as a reaction to 'removed' event.\n  if (this._parent === newParent) {\n    return\n  }\n  if (this._parent !== null) {\n    this._removeElementOf(this._parent)\n  }\n\n  setParentSuperProto.call(this, newParent)\n}\n\np.unmount = function () {\n  // Detach the view from HTML DOM\n\n  if (!this.isMounted()) {\n    // No need to remove anything.\n    // Unnecessary unmount call can be a programming error\n    // but sometimes we just want to be sure the view is unmounted.\n    return\n  }\n\n  // No need to react to events in the space.\n  this.off('added', this._viewHandlers.added)\n  this.off('transformed', this._viewHandlers.transformed)\n  this._viewHandlers = {}\n\n  // Detach all rendered elements.\n  // Note that unmount can be called before first setParent.\n  if (this._parent) {\n    this._removeElementOf(this._parent)\n  }\n\n  // Forget now empty container,\n  // so that possible next mount goes smoothly.\n  this._el = null\n}\n\np.refreshSize = function () {\n  // Recompute size from the container element.\n  // See [2]\n  if (this.isMounted()) {\n    this._setSize(this._el.clientWidth, this._el.clientHeight)\n  } else {\n    throw new Error('Unmounted view cannot be resized.')\n  }\n}\n\np.setSize = function () {\n  // Override AbstractRectangle#setSize\n  throw new Error('Use refreshSize to resize the view.')\n}\n\np.setISize = function () {\n  // Override AbstractRectangle#setISize\n  throw new Error('Use refreshSize to resize the view.')\n}\n\n// Private(ish) methods\n\np._getViewSpecificId = function (abstractNodeId) {\n  // Each rendered element has own ID. The ID differs from\n  // the id of space nodes because a space node can become\n  // visualized through multiple views.\n  return this.id + '-' + abstractNodeId\n}\n\np._removeElementOf = function (abstractNode) {\n  // Removes the HTMLElement of abstractNode.\n  // Does not remove the abstractNode from the view,\n  // only from DOM.\n  //\n  // Note that the give abstractNode is probably already detached from\n  // the Space. Therefore abstractNode.isRoot() probably returns true and\n  // cannot be used to determine if the abstractNode is space.\n  var el, on\n  var view = this\n  var n = abstractNode // alias\n\n  if (!this.isMounted()) {\n    throw new Error('Cannot remove element when view is not mounted.')\n  }\n\n  // Recursively remove the children first\n  n.getChildren().forEach(function (child) {\n    view._removeElementOf(child)\n  })\n\n  // Remove event handlers and the element.\n  on = this._handlers[n.id]\n\n  if (n === this || n === this._parent) {\n    // When AbstractNode is the Space or SpaceView itself,\n    // only a handler for childAdded has been created.\n    n.off('childAdded', on.childAdded)\n  } else {\n    n.off('childAdded', on.childAdded)\n    n.off('removed', on.removed)\n    n.off('resized', on.resized)\n    n.off('transformed', on.transformed)\n  }\n\n  el = this._elements[n.id]\n  delete el[DOM_SPACENODE_PROPERTY]\n  delete this._elements[n.id]\n  delete this._handlers[n.id]\n\n  // Remove from DOM\n  el.parentElement.removeChild(el)\n}\n\np._renderElementFor = function (abstractNode) {\n  // Creates the element for abstractNode and renders it\n  // to the view. Renders also the children of the node.\n  var el, parentEl, on\n  var view = this\n  var n = abstractNode\n\n  // Ensure that the view if mounted to DOM. Otherwise\n  // asking for the render is a bug.\n  if (!this.isMounted()) {\n    throw new Error('Do not render elements before mounting the view')\n  }\n\n  // Prevent bugs that double-render elements\n  if (this._elements.hasOwnProperty(n.id)) {\n    throw new Error('An element should not be added twice to the same view.')\n  }\n\n  // Create HTMLElement for the node.\n  // If the node is Space, SpaceGroup, or SpaceView,\n  // a special 0x0 div is created.\n  // Provide SpaceView constructor to avoid a circular dependency.\n  el = createElementFor(n, SpaceView)\n  // Each must have unique ID so we can reference to them.\n  el.id = this._getViewSpecificId(n.id)\n\n  // Allow reference from the element to the abstractNode and vice versa.\n  // It becomes important to carefully undo the reference\n  // to prevent memory leaks.\n  el[DOM_SPACENODE_PROPERTY] = n\n  this._elements[n.id] = el\n\n  if (n === this._parent) {\n    // AbstractNode is Space. Space has a special handling for its HTMLElement.\n    // The element is transformed only when the view transforms.\n    // This is the way how the transformation of the view affects to\n    // the CSS3 transforms of HTMLElements of the children\n    // of the space. The browser takes a product of the CSS3 transforms\n    // of HTMLElement and its parents.\n\n    // Add the element to the view's container.\n    this._el.appendChild(el)\n\n    // Define how view should react to changes in Space.\n    // Note that Space cannot emit 'removed', 'resized', or 'transformed'\n    on = {\n      childAdded: function (ev) {\n        // Child added to root, therefore render it to view.\n        // However, if the child is the view itself, do not render\n        // because the view has been already rendered in the view's\n        // handler for the 'added' event. See note [1] for details.\n        if (ev.newChild !== view) {\n          // If parent does not change, we only need to rearrange the elements.\n          if (ev.oldParent === ev.source) {\n            view._reorderElementOf(ev.newChild)\n          } else {\n            view._renderElementFor(ev.newChild)\n          }\n        }\n      }\n    }\n    n.on('childAdded', on.childAdded)\n  } else {\n    // Is a descendant of Space\n\n    // Add the new element to the parent element.\n    parentEl = this._elements[n.getParent().id]\n    parentEl.appendChild(el)\n\n    // Define how view should react to changes in AbstractNode\n    // by setting up handlers.\n\n    if (n === this) {\n      // View itself is a descendant of Space and therefore _renderElementFor\n      // is called also for the view's AbstractNode.\n      //\n      // If the view's AbstractNode becomes removed, the view has\n      // a special handling for that, defined in unmount().\n      //\n      // If the view's AbstractNode becomes resized, the view has\n      // a special handler for that, defined in mount() TODO.\n      // The HTMLElement for the view is a 0x0 and should remain so\n      // and therefore we cannot use the default _resizeElementOf.\n      //\n      // If the view becomes transformed, there is no need to\n      // transform it's HTMLElement because the element should stay still.\n      // By avoiding unnecessary retransformation we also avoid possible\n      // rounding errors.\n      //\n      // Note that we bound has childAdded handler also for the view.\n      // This way we can fix elements to the view, like a health bar, or\n      // dropdown menu.\n      //\n      on = {\n        childAdded: function (ev) {\n          // Child added. If the parent does not change, we only need to\n          // rearrange the elements.\n          if (ev.oldParent === ev.source) {\n            view._reorderElementOf(ev.newChild)\n          } else {\n            view._renderElementFor(ev.newChild)\n          }\n        }\n      }\n      n.on('childAdded', on.childAdded)\n    } else {\n      // Is a descendant of the root and not the view itself.\n      on = {\n        childAdded: function (ev) {\n          // If the parent does not change, we only need to\n          // rearrange the elements.\n          if (ev.oldParent === ev.source) {\n            view._reorderElementOf(ev.newChild)\n          } else {\n            view._renderElementFor(ev.newChild)\n          }\n        },\n        removed: function (ev) {\n          if (ev.oldParent === ev.newParent) {\n            // Rearrange elements in childAdded handler.\n          } else {\n            view._removeElementOf(n)\n          }\n        },\n        resized: function () {\n          view._resizeElementOf(n)\n        },\n        transformed: function () {\n          setElementTransform(view._elements[n.id], n._T)\n        }\n      }\n\n      n.on('childAdded', on.childAdded)\n      n.on('removed', on.removed)\n      n.on('resized', on.resized)\n      n.on('transformed', on.transformed)\n\n      // Initial size and transformation\n      if (n instanceof AbstractRectangle) {\n        on.resized()\n      }\n      on.transformed()\n    }\n  }\n\n  // Store for _removeElementOf\n  this._handlers[n.id] = on\n\n  // Repeat for children to render everything.\n  n.getChildren().forEach(function (child) {\n    view._renderElementFor(child)\n  })\n}\n\np._reorderElementOf = function (item) {\n  // Item's order has probably changed in space. We manipulate\n  // the DOM so that the element order matches the order in space.\n  var el, parentEl, nextSibling, nextEl\n\n  el = this._elements[item.id]\n  parentEl = this._elements[item._parent.id]\n\n  nextSibling = item.getNextSibling()\n\n  if (nextSibling) {\n    // Next sibling exists. Move the item's element so that it becomes before.\n    nextEl = this._elements[nextSibling.id]\n    parentEl.insertBefore(el, nextEl)\n  } else {\n    // Item is the last. Move the element last.\n    parentEl.appendChild(el)\n  }\n}\n\np._resizeElementOf = function (item) {\n  var el, wh\n  wh = item.getSize()\n  el = this._elements[item.id]\n  el.style.width = wh.width + 'px'\n  el.style.height = wh.height + 'px'\n}\n\n// As we override setSize, provide private access to AbstractRectangle#setSize\np._setSize = AbstractRectangle.prototype.setSize\n\nmodule.exports = SpaceView\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/SpaceView/index.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/SpaceView/setElementTransform.js":
/*!********************************************************************!*\
  !*** ./node_modules/tapspace/lib/SpaceView/setElementTransform.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var PREC = 8\n\nmodule.exports = function (el, tr) {\n  // Update transformation of a HTMLElement.\n  // They are HTMLElements parented on view's container, not nodes on space.\n  //\n  var s, r, mr, tx, ty\n\n  // Current move.js does not prevent scientific notation reaching CSS\n  // which leads to problems with Safari and Opera. Therefore we must\n  // prevent the notation here.\n  // Of course this will cause a small deviation in the presentation.\n  // However the deviation is only in the presentation and thus not a problem.\n  s = tr.s.toFixed(PREC)\n  r = tr.r.toFixed(PREC)\n  mr = (-tr.r).toFixed(PREC)\n  tx = tr.tx.toFixed(PREC)\n  ty = tr.ty.toFixed(PREC)\n\n  // matrix(s, r, -r, s, tx, ty)\n  el.style.transform = 'matrix(' +\n    s + ',' + r + ',' + mr + ',' + s + ',' + tx + ',' + ty +\n  ')'\n}\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/SpaceView/setElementTransform.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/Touchable/MouseConverter.js":
/*!***************************************************************!*\
  !*** ./node_modules/tapspace/lib/Touchable/MouseConverter.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nvar startMouseConversion = function (container) {\n  // Re-emit mouse events as custom touch-like events, \"rats\".\n  // The mouse events that reach the given HTMLElement are converted so\n  // that the initial mouse event target el is remembered even\n  // when the mouse exits it.\n  // This prevents the gestureend being emitted when the mouse leaves the\n  // original target, even temporarily. That brings a big improvement to\n  // panning with a mouse over lots of small items.\n  //\n  // Parameters\n  //   container\n  //     HTMLElement\n  //\n\n  // Mouse pressed down\n  var mouseDown = false\n\n  var originalTarget = null\n  var bubbles = true\n  var cancelable = true\n\n  var onMouseDown = function (mouseEv) {\n    if (!mouseDown && !mouseEv.defaultPrevented) {\n      mouseDown = true\n\n      // Remember the original target\n      originalTarget = mouseEv.target\n\n      // Construct the event\n      var ev = document.createEvent('Event')\n      ev.initEvent('ratstart', bubbles, cancelable)\n\n      ev.target = originalTarget\n      ev.pageX = mouseEv.pageX\n      ev.pageY = mouseEv.pageY\n\n      // Dispatch the rat. If it was cancelled, cancel also the original.\n      var defaultPrevented = !originalTarget.dispatchEvent(ev)\n      if (defaultPrevented) {\n        mouseEv.preventDefault()\n      }\n    }\n  }\n\n  var onMouseMove = function (mouseEv) {\n    if (mouseDown && !mouseEv.defaultPrevented) {\n      // Construct the rat event\n      var ev = document.createEvent('Event')\n      ev.initEvent('ratmove', bubbles, cancelable)\n\n      ev.target = originalTarget\n      ev.pageX = mouseEv.pageX\n      ev.pageY = mouseEv.pageY\n\n      // Dispatch the rat. If it was cancelled, cancel also the original.\n      var defaultPrevented = !originalTarget.dispatchEvent(ev)\n      if (defaultPrevented) {\n        mouseEv.preventDefault()\n      }\n    }\n  }\n\n  var onMouseUp = function (mouseEv) {\n    if (mouseDown && !mouseEv.defaultPrevented) {\n      mouseDown = false\n\n      var ev = document.createEvent('Event')\n      ev.initEvent('ratend', bubbles, cancelable)\n\n      ev.target = originalTarget\n      ev.pageX = mouseEv.pageX\n      ev.pageY = mouseEv.pageY\n\n      // Dispatch the rat. If it was cancelled, cancel also the original.\n      var defaultPrevented = !originalTarget.dispatchEvent(ev)\n      if (defaultPrevented) {\n        mouseEv.preventDefault()\n      }\n\n      // Forget the target. Just to be sure.\n      originalTarget = null\n    }\n  }\n\n  // Do not let our custom rat events escape.\n  // Note that stopPropagation does not affect\n  // the return value of dispatchEvent. Therefore\n  // the original mouse events become cancelled\n  // only if the rat events are explicitly cancelled.\n  // Note terminology: cancel = preventDefault.\n  var stop = function (customEvent) {\n    customEvent.stopPropagation()\n  }\n\n  container.addEventListener('mousedown', onMouseDown)\n  container.addEventListener('mousemove', onMouseMove)\n  container.addEventListener('mouseup', onMouseUp)\n  container.addEventListener('mouseleave', onMouseUp)\n\n  container.addEventListener('ratstart', stop)\n  container.addEventListener('ratmove', stop)\n  container.addEventListener('ratend', stop)\n\n  // Return handlers so that the listeners can be removed.\n  return {\n    container: container,\n    mousedown: onMouseDown,\n    mousemove: onMouseMove,\n    mouseup: onMouseUp,\n    mouseleave: onMouseUp,\n    ratstart: stop,\n    ratmove: stop,\n    ratend: stop\n  }\n}\n\nvar stopMouseConversion = function (handlers) {\n  var h = handlers\n  var c = h.container\n\n  c.removeEventListener('mousedown', h.mousedown)\n  c.removeEventListener('mousemove', h.mousemove)\n  c.removeEventListener('mouseup', h.mouseup)\n  c.removeEventListener('mouseleave', h.mouseleave)\n\n  c.removeEventListener('ratstart', h.ratstart)\n  c.removeEventListener('ratmove', h.ratmove)\n  c.removeEventListener('ratend', h.ratend)\n}\n\nvar MouseConverter = function () {\n  // Mapping from view ids to number of start calls.\n  // We keep count to be able to remove listeners on last stop call.\n  this.numRunning = {}\n\n  // Mapping from view ids to handler bundles returned by\n  this.handlers = {}\n}\n\nMouseConverter.prototype.start = function (view) {\n  // If already running\n  if (this.numRunning.hasOwnProperty(view.id)) {\n    this.numRunning[view.id] += 1\n    return // only increase the counter\n  }\n\n  // Init the counter\n  this.numRunning[view.id] = 1\n\n  // Begin conversion for the view.\n  this.handlers[view.id] = startMouseConversion(view.getContainer())\n}\n\nMouseConverter.prototype.stop = function (view) {\n  // Stops conversion when stop() is called as many\n  // times as start for the view.\n  if (this.numRunning.hasOwnProperty(view.id)) {\n    this.numRunning[view.id] -= 1\n  } else {\n    throw new Error('Stop called before start.')\n  }\n\n  if (this.numRunning[view.id] < 1) {\n    stopMouseConversion(this.handlers[view.id])\n    delete this.numRunning[view.id]\n    delete this.handlers[view.id]\n  }\n}\n\nmodule.exports = MouseConverter\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/Touchable/MouseConverter.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/Touchable/Recognizer.js":
/*!***********************************************************!*\
  !*** ./node_modules/tapspace/lib/Touchable/Recognizer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\nRecognizer\n\nHandles integration to Tapspace and higher level events such as tap event.\n\nKeep all tapspace-related stuff in Recognizer.\nKeep Sensor compatible with all html elements.\n\nNotes\n  [1]\n    For press event detection, we can place a threshold how far\n    we allow fingers to move to still classify it as a press.\n\n*/\nvar Sensor = __webpack_require__(/*! ./Sensor */ \"./node_modules/tapspace/lib/Touchable/Sensor.js\")\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/tapspace/lib/Touchable/utils.js\")\nvar ITransform = __webpack_require__(/*! ../geom/ITransform */ \"./node_modules/tapspace/lib/geom/ITransform.js\")\nvar IVector = __webpack_require__(/*! ../geom/IVector */ \"./node_modules/tapspace/lib/geom/IVector.js\")\nvar Vector = __webpack_require__(/*! ../geom/Vector */ \"./node_modules/tapspace/lib/geom/Vector.js\")\nvar nudged = __webpack_require__(/*! nudged */ \"./node_modules/nudged/index.js\")\n\nvar toRawPivot = function (mode, plane) {\n  // The pivot needs to be converted to [x, y]\n  // on plane's coordinate plane.\n  //\n  if (mode.pivot) {\n    return mode.pivot.to(plane).toArray()\n  }\n\n  // Use middle of plane as a default pivot if translation not allowed.\n  if (mode.translate === false) {\n    return plane.atMid().to(plane).toArray()\n  }\n\n  // Return undefined so that when rawPivot is given as a parameter\n  // to Sensor, it looks like the parameter was not given.\n}\n\nvar rebase = function (pointers, sourcePlane, targetPlane) {\n  // Represent pointers on another AbstractPlane\n  //\n  // Parameters\n  //   pointers\n  //     a map: id -> [x, y]\n  //   sourcePlane\n  //     a AbstractPlane of the pointers\n  //   targetPlane\n  //     a AbstractPlane of the returned pointers\n  //\n  // Return\n  //   object, a map: id -> [x, y]\n  //\n  if (sourcePlane === targetPlane) {\n    return pointers\n  }\n\n  var k\n  var result = {}\n  var sourceToSpace = sourcePlane.getGlobalTransform()\n  var targetToSpace = targetPlane.getGlobalTransform()\n  var sourceToTarget = targetToSpace.inverse().multiplyRight(sourceToSpace)\n  for (k in pointers) {\n    if (pointers.hasOwnProperty(k)) {\n      result[k] = sourceToTarget.transform(pointers[k])\n    }\n  }\n  return result\n}\n\nvar rebaseToSpace = function (pointers, sourcePlane) {\n  var k\n  var result = {}\n  var sourceToSpace = sourcePlane.getGlobalTransform()\n  for (k in pointers) {\n    if (pointers.hasOwnProperty(k)) {\n      result[k] = sourceToSpace.transform(pointers[k])\n    }\n  }\n  return result\n}\n\nvar toTapPoints = function (ps) {\n  // Params:\n  //   ps: map id->[x,y] on space\n  var k\n  var result = []\n  for (k in ps) {\n    if (ps.hasOwnProperty(k)) {\n      result.push(new IVector(new Vector(ps[k][0], ps[k][1])))\n    }\n  }\n  return result\n}\n\nvar multiplyLeft = function (pointers, transform) {\n  // Transform pointers. Regard pointers as a row vector\n  // of column vectors. Multiply each column vector from left by\n  // a transformation matrix.\n  var k\n  var result = {}\n  for (k in pointers) {\n    if (pointers.hasOwnProperty(k)) {\n      result[k] = transform.transform(pointers[k])\n    }\n  }\n  return result\n}\n\nvar Recognizer = function (manager) {\n  // Create a Recognizer\n  //   var rec = new Recognizer(...)\n  //\n  // Parameters:\n  //   manager\n  //     Touchable with the following properties\n  //       element\n  //         HTML element to listen to\n  //       item\n  //         a tapspace.AbstractPlane, the object on the gesture happens\n  //       targetItem\n  //         a tapspace.AbstractPlane or function (ITransform itr).\n  //         The object to move or a function to call.\n  //       view\n  //         a tapspace.SpaceView\n  //       mode\n  //         a transformation type\n  //\n  var self = this\n\n  this.man = manager\n\n  var startTime = null\n  var totalTravel = null\n  var pointersOnItem = {}\n  var touchPointLog = {} // starting points\n\n  var onStart = function (firstPointers) {\n    // On gesture start. Handle the first pointer(s) of the gesture.\n    //\n    var sourceItem = self.man.item\n    var view = self.man.view\n    var el = self.man.element\n\n    startTime = Date.now()\n    totalTravel = 0\n\n    pointersOnItem = rebase(firstPointers, view, sourceItem)\n\n    touchPointLog = rebaseToSpace(firstPointers, view)\n\n    self.man.emit('gesturestart', {\n      distance: 0,\n      duration: 0,\n      element: el,\n      item: self.man.targetItem\n    })\n  }\n\n  var onMove = function (prevPointers, nextPointers) {\n    var k, n, pivot, type, tr, itr\n    var domain = []\n    var range = []\n    var el = self.man.element\n    var view = self.man.view\n    var sourceItem = self.man.item\n    var targetItem = self.man.targetItem\n    var mode = self.man.mode\n\n    // Current location of new pointers on the plane.\n    // This approach zeroes the effects caused by\n    // 1) transformations of the view\n    // 2) transformations of the parents of the source item\n    var nextPointersOnItem = rebase(nextPointers, view, sourceItem)\n\n    // Set intersection. Do not use removed or appeared pointers\n    // in transformation estimation.\n    for (k in pointersOnItem) {\n      if (pointersOnItem.hasOwnProperty(k) &&\n          nextPointersOnItem.hasOwnProperty(k)) {\n        domain.push(pointersOnItem[k])\n        range.push(nextPointersOnItem[k])\n      }\n    }\n\n    // Record the space locations of the new pointers to\n    // provide them in the tap event.\n    var viewToSpace = view.getGlobalTransform()\n    for (k in nextPointersOnItem) {\n      if (nextPointersOnItem.hasOwnProperty(k) &&\n          !touchPointLog.hasOwnProperty(k)) {\n        // New pointer\n        touchPointLog[k] = viewToSpace.transform(nextPointersOnItem[k])\n      }\n    }\n\n    // Accumulate to travelled distance. See [1]\n    // Use Manhattan distance for simpler computation.\n    // Goal is to form a threshold to filter out small\n    // involuntary movement of the fingers or arm.\n    //\n    // N. Divide distance by number of fingers. This way\n    // an involuntary arm movement has same threshold regardless of\n    // the number of touching fingers.\n    //\n    // Note that we compute travel on view instead of travel on\n    // the plane. This way travel does not depend on transformations\n    // of the space, but only the screen pixels.\n    n = domain.length\n    for (k in prevPointers) {\n      if (prevPointers.hasOwnProperty(k) && nextPointers.hasOwnProperty(k)) {\n        totalTravel += Math.abs(prevPointers[k][0] - nextPointers[k][0]) / n\n        totalTravel += Math.abs(prevPointers[k][1] - nextPointers[k][1]) / n\n      }\n    }\n\n    // Compute current position of the pivot on the plane.\n    // Pivot will be undefined if mode has no pivot but enables translation.\n    pivot = toRawPivot(mode, sourceItem)\n    // Get current nudged-compatible transformation type string\n    type = utils.convertToTransformationType(mode)\n\n    // Estimate optimal transformation\n    tr = nudged.estimate(type, domain, range, pivot)\n\n    // Apply the transformation to targetItem. We also\n    // memorize the new pointers for the next onMove call.\n    // We want to memorize only their relative location on the source item.\n    // This way transformations of the view and parents between\n    // onMove calls become part of the resulting transformation.\n    // Note that transformBy emits 'transformed' that might eventually\n    // cause transformations in the space. Therefore we should do all\n    // coordinate-plane conversions before transformBy to avoid weird bugs.\n\n    itr = new ITransform(tr, sourceItem)\n\n    if (typeof targetItem === 'function') {\n      pointersOnItem = nextPointersOnItem\n      targetItem(itr)\n    } else if (view === targetItem) {\n      // Somehow we do not need the following line with views:\n      // pointersOnItem = multiplyLeft(nextPointersOnItem, tr)\n      // If we use the line, everything shakes.\n      pointersOnItem = nextPointersOnItem\n      view.transformBy(itr.inverse())\n    } else {\n      // The sourceItem moves, but the stored pointer locations\n      // should not. Thus undo the effect the transformation\n      // would have to the stored pointer locations.\n      pointersOnItem = multiplyLeft(nextPointersOnItem, tr.inverse())\n      targetItem.transformBy(itr)\n    }\n\n    self.man.emit('gesturemove', {\n      distance: totalTravel,\n      duration: Date.now() - startTime,\n      element: el,\n      item: targetItem\n    })\n  }\n\n  var onEnd = function (lastPointers) {\n    // Handle the last pointer(s) of the gesture\n    //\n    var el = self.man.element\n    var targetItem = self.man.targetItem\n    var mode = self.man.mode\n\n    self.man.emit('gestureend', {\n      distance: totalTravel,\n      duration: Date.now() - startTime,\n      element: el,\n      item: targetItem\n    })\n\n    if (mode.tap && totalTravel < mode.tapMaxTravel) {\n      self.man.emit('tap', {\n        distance: totalTravel,\n        duration: Date.now() - startTime,\n        element: el,\n        item: targetItem,\n        points: toTapPoints(touchPointLog)\n      })\n    }\n\n    pointersOnItem = {}\n    touchPointLog = {}\n  }\n\n  // Handlers defined, construct sensor\n  this.sensor = new Sensor(this.man.element, {\n    start: onStart,\n    move: onMove,\n    end: onEnd\n  }, this.man.mode)\n}\n\nRecognizer.prototype.update = function (mode) {\n  this.sensor.update(mode)\n}\n\nRecognizer.prototype.destroy = function () {\n  this.sensor.destroy()\n}\n\nmodule.exports = Recognizer\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/Touchable/Recognizer.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/Touchable/Sensor.js":
/*!*******************************************************!*\
  !*** ./node_modules/tapspace/lib/Touchable/Sensor.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\nSensor\n\nDefines how different input devices are normalized into\npointer id, x, and y.\n\nKeep all tapspace-related stuff in Recognizer.\nKeep Sensor compatible with all html elements.\n\nNotes:\n  [1] Count them the hard way to avoid difference between a possible counter\n      and the actual number of pointers. An \"easy\" way would be to maintain\n      a variable that keeps record on the number of fingers.\n  [2] Clone always. Only the clone can be modified.\n      Take this functional approach to avoid bugs. We experienced\n      a situation where modification of the pointers caused\n      suprising state changes outside of Sensor.\n*/\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/tapspace/lib/Touchable/utils.js\")\n\nmodule.exports = function Sensor (element, handlers, opts) {\n  // Parameters:\n  //   element\n  //     HTMLElement to listen to\n  //   handlers\n  //     start\n  //       function (firstPointers), called once when the first pointer\n  //       enters the screen.\n  //     move\n  //       function (prevPointers, nextPointers)\n  //     end\n  //       function (lastPointers), called once when the last pointer\n  //       exits the screen.\n  //   opts\n  //     preventDefault\n  //       boolean\n\n  // We need to remember listeners we make to be able to remove them\n  // and only them.\n  var _listeners = {}\n\n  // Use _ to emphasize private variables.\n  var _preventDefault = opts.preventDefault\n  var _handlers = handlers\n  var _el = element\n\n  // Gesture started\n  var _started = false\n\n  // Mouse pressed down\n  var _mouseDown = false\n\n  // Current active pointers\n  var _currPointers = {}\n\n  // Touch support\n\n  var onTouchStart = function (ev) {\n    var cts, i, nextPointers\n\n    if (!ev.defaultPrevented) {\n      if (_preventDefault) {\n        ev.preventDefault()\n      }\n\n      nextPointers = utils.clone(_currPointers) // See [2]\n\n      cts = ev.changedTouches\n      for (i = 0; i < cts.length; i += 1) {\n        nextPointers[cts[i].identifier] = [cts[i].pageX, cts[i].pageY]\n      }\n\n      if (!_started) {\n        _started = true\n        _handlers.start(nextPointers)\n      }\n\n      _currPointers = nextPointers\n    }\n  }\n\n  var onTouchMove = function (ev) {\n    var cts, i, id, nextPointers\n\n    if (!ev.defaultPrevented) {\n      if (_preventDefault) {\n        ev.preventDefault()\n      }\n\n      nextPointers = utils.clone(_currPointers)\n\n      cts = ev.changedTouches\n      for (i = 0; i < cts.length; i += 1) {\n        // Update only pointers that were started in this Touchable.\n        // For example. ev.changedTouches contains _all_ changed touches\n        // in Chrome on Android regardless of their target. See issue #87\n        id = cts[i].identifier\n        if (nextPointers.hasOwnProperty(id)) {\n          nextPointers[id] = [cts[i].pageX, cts[i].pageY]\n        }\n      }\n\n      if (_started) {\n        _handlers.move(_currPointers, nextPointers)\n      }\n\n      _currPointers = nextPointers\n    }\n  }\n\n  var onTouchEndTouchCancel = function (ev) {\n    var cts, i, nextPointers\n\n    if (!ev.defaultPrevented) {\n      if (_preventDefault) {\n        ev.preventDefault()\n      }\n\n      nextPointers = utils.clone(_currPointers)\n\n      cts = ev.changedTouches\n      for (i = 0; i < cts.length; i += 1) {\n        // We assume that ending pointers are not moved from last touchmove\n        // although the coordinates could be accessed via\n        // ev.changedTouches[i].pageX and .pageY.\n        delete nextPointers[cts[i].identifier]\n      }\n\n      // See [1]\n      if (utils.cardinality(nextPointers) < 1) {\n        _started = false\n        // Note: we send last pointers, not the next.\n        _handlers.end(_currPointers)\n      }\n\n      _currPointers = nextPointers\n    }\n  }\n\n  // Mouse support\n  // No hover support.\n\n  var onMouseDown = function (ev) {\n    var nextPointers\n\n    if (!ev.defaultPrevented) {\n      if (_preventDefault) {\n        ev.preventDefault()\n      }\n\n      if (!_mouseDown) {\n        _mouseDown = true\n\n        nextPointers = utils.clone(_currPointers) // See [2]\n        nextPointers['mouse'] = [ev.pageX, ev.pageY]\n\n        if (!_started) {\n          _started = true\n          _handlers.start(nextPointers)\n        }\n\n        _currPointers = nextPointers\n      }\n    }\n  }\n\n  var onMouseMove = function (ev) {\n    var nextPointers\n\n    if (_mouseDown && !ev.defaultPrevented) {\n      if (_preventDefault) {\n        ev.preventDefault()\n      }\n\n      nextPointers = utils.clone(_currPointers)\n      nextPointers['mouse'] = [ev.pageX, ev.pageY]\n\n      _handlers.move(_currPointers, nextPointers)\n\n      _currPointers = nextPointers\n    }\n  }\n\n  var onMouseUp = function (ev) {\n    var nextPointers\n\n    if (_mouseDown && !ev.defaultPrevented) {\n      _mouseDown = false\n\n      if (_preventDefault) {\n        ev.preventDefault()\n      }\n\n      nextPointers = utils.clone(_currPointers)\n      delete nextPointers['mouse']\n\n      // See [1]\n      if (utils.cardinality(nextPointers) < 1) {\n        _started = false\n        // Last pointers instead of the next.\n        _handlers.end(_currPointers)\n      }\n\n      _currPointers = nextPointers\n    }\n  }\n\n  // See issue #80 for explanation for 'passive: false'\n  _el.addEventListener('touchstart', onTouchStart, { passive: false })\n  _el.addEventListener('touchmove', onTouchMove, { passive: false })\n  _el.addEventListener('touchend', onTouchEndTouchCancel)\n  _el.addEventListener('touchcancel', onTouchEndTouchCancel)\n  _el.addEventListener('ratstart', onMouseDown)\n  _el.addEventListener('ratmove', onMouseMove)\n  _el.addEventListener('ratend', onMouseUp)\n\n  _listeners.touchstart = onTouchStart\n  _listeners.touchmove = onTouchMove\n  _listeners.touchend = onTouchEndTouchCancel\n  _listeners.touchcancel = onTouchEndTouchCancel\n  _listeners.ratstart = onMouseDown\n  _listeners.ratmove = onMouseMove\n  _listeners.ratend = onMouseUp\n\n  // Bind public methods to this instead of prototype to\n  // enable uglified (short) private variable names.\n\n  this.update = function (opts) {\n    _preventDefault = opts.preventDefault\n  }\n\n  this.destroy = function () {\n    // Remove all listeners we made\n    for (var k in _listeners) {\n      if (_listeners.hasOwnProperty(k)) {\n        _el.removeEventListener(k, _listeners[k])\n      }\n    }\n    _listeners = null\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/Touchable/Sensor.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/Touchable/index.js":
/*!******************************************************!*\
  !*** ./node_modules/tapspace/lib/Touchable/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\nTouchable\n\nAn InputManager for touch events and mouse drag.\nIn comparision to Recognizer and Sensor, this module\ndefines the public methods, API.\n\nNotes:\n[1] As a design detail, the handling of element could be located\n    within Recognizer and hidden from Touchable. However, it is\n    convenient for Touchable API users to access the element by touch.element.\n[2] Mouse events do not provide info about where the drag started\n    unlike touch events. Therefore we capture mouse events on\n    the view container, store the target of the mousedown and\n    emit our custom events to be handled by the Sensor.\n    See utils.startMouseConversion\n\n*/\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\")\nvar Recognizer = __webpack_require__(/*! ./Recognizer */ \"./node_modules/tapspace/lib/Touchable/Recognizer.js\")\nvar MouseConverter = __webpack_require__(/*! ./MouseConverter */ \"./node_modules/tapspace/lib/Touchable/MouseConverter.js\")\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/tapspace/lib/Touchable/utils.js\")\n\n// See [2]\nvar converter = new MouseConverter()\n\nvar Touchable = function (view, sourceItem, targetItem) {\n  // Make it possible to transform or press a AbstractPlane by hand.\n  //\n  // Parameters:\n  //   view\n  //     SpaceView of the HTMLElement to listen.\n  //   sourceItem\n  //     an AbstractPlane, the item to make touchable in the given view.\n  //     The item must have an element in the view.\n  //   targetItem\n  //     optional AbstractPlane or function, the target for detected\n  //     transformations. Defaults to sourceItem.\n  //     If function is given, it is called every time a targetItem\n  //     would be transformed. Recognized ITransform is provided as 1st arg.\n  //     Usage example: a drag handle that can move its larger parent.\n  //\n  Emitter(this)\n\n  if (view.getContainer() === null) {\n    throw new Error('Touchable requires a mounted view.')\n  }\n\n  this.view = view\n\n  // Source item. We detect transformations from the element of this item.\n  this.item = sourceItem\n\n  if (typeof targetItem === 'undefined') {\n    this.targetItem = sourceItem\n  } else {\n    this.targetItem = targetItem\n  }\n\n  // For pointer events (touch, mouse), we listen to the HTMLElement of\n  // the given item. However, if the item is\n  // the view itself, we must listen to the container element\n  // of the view. This is because pointer events eventually\n  // bubble to the container, instead of the view's own 0x0 div,\n  // that receives only the pointer events of the children of the view.\n  // See also [1] for note about code structure regarding elements.\n  if (this.view === this.item) {\n    this.element = this.view.getContainer()\n  } else {\n    this.element = this.view.getElementBySpaceItem(this.item)\n\n    // Ensure the element exists\n    if (this.element === null) {\n      throw new Error('No HTMLElement found. ' +\n        'Ensure the item is in the same space with the view.')\n    }\n  }\n\n  // Init interaction mode.\n  this.mode = Touchable.DEFAULT_MODE\n\n  this._rec = null // A Recognizer. Null means deactive state.\n}\n\nTouchable.DEFAULT_MODE = {\n  rotate: false,\n  scale: false,\n  translate: false,\n  tap: false,\n  tapMaxTravel: 20,\n  pivot: null,\n  preventDefault: true\n}\n\nTouchable.prototype.start = function (mode) {\n  // Set current interaction mode. It is a combination of\n  // a transformation mode and a press mode.\n  //\n  // Parameters:\n  //   mode:\n  //     pivot: a tapspace.IVector\n  //     preventDefault: bool\n  //     rotate: bool\n  //     scale: bool\n  //     translate: bool\n  //     tap: bool\n  //     tapMaxTravel: number\n  //\n\n  // Ensure mouse event conversion is running for the view. See [2].\n  converter.start(this.view)\n\n  // Reset interaction mode and then add the given mode options.\n  this.mode = utils.extend(Touchable.DEFAULT_MODE, mode)\n\n  // Create or alternatively update the manager on the fly.\n  if (this._rec === null) {\n    this._rec = new Recognizer(this)\n  } else {\n    this._rec.update(this.mode)\n  }\n}\n\nTouchable.prototype.restart = function (mode) {\n  // Alias for start() but is more readable if recognition is really\n  // \"re\"started.\n  return this.start(mode)\n}\n\nTouchable.prototype.resume = function () {\n  // Restart with the previous mode.\n  if (this._rec === null) {\n    this.start(this.mode)\n  }\n}\n\nTouchable.prototype.stop = function () {\n  // Turn touchability off\n  if (this._rec !== null) {\n    this._rec.destroy()\n    this._rec = null\n\n    // Ensure that mouse conversion is stopped at the last stop call.\n    converter.stop(this.view)\n  }\n}\n\nmodule.exports = Touchable\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/Touchable/index.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/Touchable/utils.js":
/*!******************************************************!*\
  !*** ./node_modules/tapspace/lib/Touchable/utils.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nexports.extend = function (target, source) {\n  // Shallow object extend.\n  // Return a new object where keys and values of the source\n  // are merged with or replaced by target's keys and values.\n  //\n  var k\n  var obj = {}\n  for (k in target) {\n    if (target.hasOwnProperty(k)) {\n      obj[k] = target[k]\n    }\n  }\n  for (k in source) {\n    if (source.hasOwnProperty(k)) {\n      obj[k] = source[k]\n    }\n  }\n  return obj\n}\n\nexports.convertToTransformationType = function (opts) {\n  // Converts transformation mode object to transformation type string.\n  //\n  // Parameters:\n  //   opts: alternative properties\n  //\n  var t = opts.translate && !opts.pivot\n  var s = opts.scale\n  var r = opts.rotate\n\n  if (t || s || r) {\n    return (t ? 'T' : '') + (s ? 'S' : '') + (r ? 'R' : '')\n  } // else\n  return 'I'\n}\n\nexports.clone = function (obj) {\n  // Shallow object copy\n  var k\n  var res = {}\n\n  for (k in obj) {\n    if (obj.hasOwnProperty(k)) {\n      res[k] = obj[k]\n    }\n  }\n\n  return res\n}\n\nexports.cardinality = function (obj) {\n  // Number of own properties\n  var k\n  var res = 0\n\n  for (k in obj) {\n    if (obj.hasOwnProperty(k)) {\n      res += 1\n    }\n  }\n\n  return res\n}\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/Touchable/utils.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/Wheelable/Recognizer.js":
/*!***********************************************************!*\
  !*** ./node_modules/tapspace/lib/Wheelable/Recognizer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// Recognizer\n//\n// Handles integration to Tapspace and how gestures are recognized.\n//\nvar Transform = __webpack_require__(/*! ../geom/Transform */ \"./node_modules/tapspace/lib/geom/Transform.js\")\nvar ITransform = __webpack_require__(/*! ../geom/ITransform */ \"./node_modules/tapspace/lib/geom/ITransform.js\")\nvar Vector = __webpack_require__(/*! ../geom/Vector */ \"./node_modules/tapspace/lib/geom/Vector.js\")\nvar IVector = __webpack_require__(/*! ../geom/IVector */ \"./node_modules/tapspace/lib/geom/IVector.js\")\n\nvar Recognizer = function (element, target, view, emitter, mode) {\n  // Create a Recognizer\n  //   var man = new Recognizer(...)\n  //\n  // Parameters:\n  //   element\n  //     HTML element to listen to\n  //   target\n  //     a tapspace.AbstractPlane or function, the object to move\n  //     or a function to call.\n  //   view\n  //     a tapspace.SpaceView\n  //   emitter\n  //     public emitter the user listens to\n  //   mode\n  //     a transformation type\n  //\n  var self = this\n\n  this.element = element\n  this.target = target\n  this.view = view\n  this.mode = mode\n  this.emitter = emitter\n\n  this.started = false\n  this.lastWheelTimeout = null\n\n  var onWheel = function (ev) {\n    ev.preventDefault()\n\n    var tr, itr, pivot, x, y, dx, dy, dz, emitObj\n\n    // Available event properties\n    x = ev.pageX\n    y = ev.pageY\n    dx = ev.deltaX\n    dy = ev.deltaY\n    dz = ev.deltaZ // for 3D-mouses\n\n    itr = ITransform.IDENTITY\n\n    if (self.mode.translate) {\n      if (self.mode.scale) {\n        pivot = new IVector(new Vector(x, y), self.view)\n        itr = itr\n          .scale(pivot, 1 + dy / 1000)\n          .translate(self.view.at(0, 0), self.view.at(dx, 0))\n      } else {\n        tr = new Transform(1, 0, dx, dy)\n        itr = new ITransform(tr, self.view)\n      }\n    } else if (self.mode.scale) {\n      pivot = new IVector(new Vector(x, y), self.view)\n      itr = itr.scale(pivot, 1 + dy / 1000)\n    }\n\n    if (self.mode.rotate) {\n      pivot = new IVector(new Vector(x, y), self.view)\n      itr = itr.rotate(pivot, dz / 1000)\n    }\n\n    if (self.view === self.target) {\n      self.view.transformBy(itr)\n    } else if (typeof self.target === 'function') {\n      self.target(itr.inverse())\n    } else {\n      self.target.transformBy(itr.inverse())\n    }\n\n    emitObj = {\n      element: self.element,\n      item: self.target,\n      originalEvent: ev\n    }\n\n    if (!self.started) {\n      self.emitter.emit('gesturestart', emitObj)\n    }\n\n    self.emitter.emit('gesturemove', emitObj)\n    self.emitter.emit('wheel', emitObj)\n\n    clearTimeout(self.lastWheelTimeout)\n    self.lastWheelTimeout = setTimeout(function () {\n      self.started = false\n      self.lastWheelTimeout = null\n      self.emitter.emit('gestureend', emitObj)\n    }, mode.endInterval)\n  }\n\n  // See issue #80 for explanation for 'passive: false'\n  this.element.addEventListener('wheel', onWheel, { passive: false })\n  this.listener = onWheel\n}\n\nRecognizer.prototype.update = function (mode) {\n  this.mode = mode\n}\n\nRecognizer.prototype.destroy = function () {\n  this.element.removeEventListener('wheel', this.listener)\n}\n\nmodule.exports = Recognizer\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/Wheelable/Recognizer.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/Wheelable/index.js":
/*!******************************************************!*\
  !*** ./node_modules/tapspace/lib/Wheelable/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// Wheelable\n//\n// Map mouse wheel input to transformations in space.\n//\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\")\nvar Recognizer = __webpack_require__(/*! ./Recognizer */ \"./node_modules/tapspace/lib/Wheelable/Recognizer.js\")\nvar utils = __webpack_require__(/*! ../Touchable/utils */ \"./node_modules/tapspace/lib/Touchable/utils.js\")\n\nvar Wheelable = function (view, sourceItem, targetItem) {\n  // Parameters\n  //   view\n  //     SpaceView of the HTMLElement to listen.\n  //   sourceItem\n  //     We detect mouse wheel events from the element of this item.\n  //   targetItem\n  //     Optional. Item or function. Defaults to the sourceItem.\n  //     The detected transformation is applied to this item.\n  //     If a function was given, the function is called each time\n  //     a transformation happens.\n  //\n  Emitter(this)\n\n  if (view.getContainer() === null) {\n    throw new Error('Wheelable requires a mounted view.')\n  }\n\n  this.view = view\n  this.sourceItem = sourceItem\n\n  if (typeof targetItem === 'undefined') {\n    this.targetItem = sourceItem\n  } else {\n    this.targetItem = targetItem\n  }\n\n  if (this.view === this.sourceItem) {\n    this.element = this.view.getContainer()\n  } else {\n    this.element = this.view.getElementBySpaceItem(this.sourceItem)\n\n    // Ensure the element exists\n    if (this.element === null) {\n      throw new Error('No HTMLElement found. ' +\n        'Ensure the item is in the same space with the view.')\n    }\n  }\n\n  // Init interaction mode.\n  this.mode = Wheelable.DEFAULT_MODE\n\n  this._rec = null // A Recognizer. Null means deactive state.\n}\n\nWheelable.DEFAULT_MODE = {\n  rotate: false,\n  scale: false,\n  translate: false,\n  endInterval: 200 // ms\n}\n\nWheelable.prototype.start = function (mode) {\n  // Set current interaction mode.\n  //\n  // Parameters:\n  //   mode:\n  //     rotate: bool\n  //     scale: bool\n  //     translate: bool\n  //\n  var el, it, v\n\n  // Reset interaction mode and then add the given mode options.\n  this.mode = utils.extend(Wheelable.DEFAULT_MODE, mode)\n\n  // Create or alternatively update the manager on the fly.\n  if (this._rec === null) {\n    el = this.element\n    it = this.targetItem\n    v = this.view\n    this._rec = new Recognizer(el, it, v, this, this.mode)\n  } else {\n    this._rec.update(this.mode)\n  }\n}\n\nWheelable.prototype.restart = function (mode) {\n  // Alias for start() but is more readable if recognition is really\n  // \"re\"started.\n  return this.start(mode)\n}\n\nWheelable.prototype.resume = function () {\n  // Restart with the previous mode.\n  if (this._rec === null) {\n    this.start(this.mode)\n  }\n}\n\nWheelable.prototype.stop = function () {\n  // Turn touchability off\n  if (this._rec !== null) {\n    this._rec.destroy()\n    this._rec = null\n  }\n}\n\nmodule.exports = Wheelable\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/Wheelable/index.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/Grid.js":
/*!************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/Grid.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// A Grid to snap transformations.\n// In other words, a Grid defines a discrete set of transformations\n// and provides methods to find the nearest transformation in the set\n// for any given transformation.\n//\nvar EPSILON = __webpack_require__(/*! ./epsilon */ \"./node_modules/tapspace/lib/geom/epsilon.js\")\nvar Vector = __webpack_require__(/*! ./Vector */ \"./node_modules/tapspace/lib/geom/Vector.js\")\nvar Path = __webpack_require__(/*! ./Path */ \"./node_modules/tapspace/lib/geom/Path.js\")\nvar extend = __webpack_require__(/*! extend */ \"./node_modules/extend/index.js\")\n\nvar DEFAULT_STEPMODE = {\n  xStep: 0,\n  yStep: 0,\n  scaleStep: 0,\n  rotateStep: 0,\n  xPhase: 0,\n  yPhase: 0,\n  scalePhase: 0,\n  rotatePhase: 0,\n  xRotation: 0, // The angle of the xy grid\n  yRotation: Math.PI / 2\n}\n\nvar snap = function (x, step, phase) {\n  // Find x' in { i * step + phase | i in N }\n  // such that abs(x - x') is minimal. N is the set of integers.\n  //\n  // Parameters:\n  //   x\n  //     number\n  //   step\n  //     number\n  //   phase\n  //     number\n  //\n  // Return\n  //   number\n  //\n  return (Math.round((x - phase) / step) * step) + phase\n}\n\nvar Grid = function (stepMode) {\n  if (typeof stepMode !== 'object') {\n    stepMode = DEFAULT_STEPMODE\n  } else {\n    stepMode = extend({}, DEFAULT_STEPMODE, stepMode)\n  }\n\n  if ((stepMode.xStep < EPSILON && stepMode.yStep > EPSILON) ||\n      (stepMode.xStep > EPSILON && stepMode.yStep < EPSILON)) {\n    throw new Error('Grid xStep and yStep must be either both zero or ' +\n      'both greater than zero.')\n    // because otherwise handling with grid basis vectors becomes\n    // unnecessarily complicated.\n  }\n\n  if (Math.abs(stepMode.xRotation - stepMode.yRotation) < EPSILON) {\n    throw new Error('Grid xRotation and yRotation cannot be the same.')\n    // because otherwise grid basis vectors become linearly dependent\n    // and could not be used as basis vectors without unnecessarily\n    // complicated checking for special cases.\n  }\n\n  this.mode = stepMode\n}\n\nvar proto = Grid.prototype\n\nproto.almostEqual = function (grid) {\n  // Return bool. True if modes of the grids are equal\n  // with a tiny margin left for floating point arithmetic rounding errors.\n  var k\n  var tm = this.mode\n  var gm = grid.mode\n\n  for (k in tm) {\n    if (tm.hasOwnProperty(k)) {\n      if (gm.hasOwnProperty(k)) {\n        if (Math.abs(tm[k] - gm[k]) > EPSILON) {\n          return false\n        }\n      } else {\n        return false\n      }\n    }\n  }\n\n  return true\n}\n\nproto.at = function (i, j) {\n  // Get a Vector to the crossing (i, j) on the grid.\n  // The vector grid.at(0,0) equals the grid.getOrigin()\n  //\n  // Return\n  //   Vector\n  //\n  var m = this.mode\n\n  if (m.xStep === 0 || m.yStep === 0) {\n    // No grid\n    return new Vector(0, 0)\n  }\n\n  // Grid basis vectors\n  var gbx = Vector.createFromPolar(m.xStep, m.xRotation)\n  var gby = Vector.createFromPolar(m.yStep, m.yRotation)\n\n  // Get origin defined by phase\n  var phx = gbx.multiply(m.xPhase / m.xStep)\n  var phy = gby.multiply(m.yPhase / m.yStep)\n  var origin = phx.add(phy)\n\n  // Add grid coordinate vectors to the origin to get the result.\n  return origin.add(gbx.multiply(i)).add(gby.multiply(j))\n}\n\nproto.equal =\nproto.equals = function (grid) {\n  // Return bool. True if modes of the grids equal.\n  //\n  var k\n  var tm = this.mode\n  var gm = grid.mode\n\n  for (k in tm) {\n    if (tm.hasOwnProperty(k)) {\n      if (gm.hasOwnProperty(k)) {\n        if (tm[k] !== gm[k]) {\n          return false\n        }\n      } else {\n        return false\n      }\n    }\n  }\n\n  return true\n}\n\nproto.getHullOf = function (i, j) {\n  // Get hull Path of (i, j):th eye of the grid.\n  // To define the (0, 0):th eye, consider the example:\n  //   Let G be grid with xStep=1, yStep=1, xPhase=0.5, yPhase=0.\n  //   Now the hull of (0, 0) is a four-point Path:\n  //   [(0.5, 0), (0.5, 1), (1.5, 1), (1.5, 0)]\n  // Thus, the eye at x,y origin may not be (0, 0).\n  //\n  // Parameters:\n  //   i\n  //     number\n  //   j\n  //     number\n  //\n  // Return:\n  //   Path\n  //   null\n  //     if xStep=0 or yStep=0\n  //\n\n  // Grid basis vectors\n  var m = this.mode\n  var gbx = Vector.createFromPolar(m.xStep, m.xRotation)\n  var gby = Vector.createFromPolar(m.yStep, m.yRotation)\n\n  // Vector to grid origin\n  var vor = this.getOrigin()\n\n  // Corners\n  var c0 = vor.add(gbx.multiply(i)).add(gby.multiply(j))\n  var c1 = vor.add(gbx.multiply(i)).add(gby.multiply(j + 1))\n  var c2 = vor.add(gbx.multiply(i + 1)).add(gby.multiply(j + 1))\n  var c3 = vor.add(gbx.multiply(i + 1)).add(gby.multiply(j))\n\n  // Call getHull to ensure correct order.\n  return (new Path([c0, c1, c2, c3])).getHull()\n}\n\nproto.getOrigin = function () {\n  // Get the origin point of the grid, specified by xPhase and yPhase.\n  //\n  // Return:\n  //   Vector\n  //\n\n  // Grid basis vectors\n  var m = this.mode\n  var gbx = Vector.createFromPolar(m.xStep, m.xRotation)\n  var gby = Vector.createFromPolar(m.yStep, m.yRotation)\n\n  // Normalize phase and turn to components\n  var phx = gbx.multiply(m.xPhase / m.xStep)\n  var phy = gby.multiply(m.yPhase / m.yStep)\n\n  // Together they point to the origin\n  return phx.add(phy)\n}\n\nproto.snap = function (pivot, tr) {\n  // Snap a Transform to the grid.\n  // In other words, find the nearest Transform allowed\n  // by the grid.\n  //\n  // Parameters\n  //   pivot\n  //     Vector, represented on the source plane of tr.\n  //   tr\n  //     Transform, a mapping from a node plane to its parent\n  //\n  // Return\n  //   Transform snapped to the grid.\n  //\n  var dx, dy\n  var gbx, gby\n  var tr1, tr2\n  var piv1, piv1g, piv2g, piv2\n  var oldScale, newScale, scalingMultiplier\n  var oldRotation, newRotation\n  var m = this.mode // short alias\n\n  // The pivot is represented on source plane but the grid\n  // is on the target. Thus convert the pivot onto target.\n  piv1 = pivot.transform(tr)\n\n  if (m.xStep === 0 || m.yStep === 0) {\n    // No x y snapping\n    piv2 = piv1\n  } else {\n    // The pivot point must hit the grid. Therefore, for starters,\n    // let us translate so that pivot is on the grid.\n    // The grid is defined by basis vectors gvx, gvy.\n    // Magnitude of gvx is xStep and direction xRotation\n    // Magnitude of gvy is yStep and direction yRotation\n    // Therefore for snapping, we change the basis of the pivot.\n    gbx = Vector.createFromPolar(m.xStep, m.xRotation) // grid basis vectors\n    gby = Vector.createFromPolar(m.yStep, m.yRotation)\n    piv1g = piv1.changeBasis(gbx, gby)\n    piv2g = new Vector(\n      snap(piv1g.x, 1, m.xPhase / m.xStep), // snap step 1 because on grid\n      snap(piv1g.y, 1, m.yPhase / m.yStep)\n    )\n    // Change basis back to original coordinate space\n    piv2 = piv2g.changeFromBasis(gbx, gby)\n  }\n\n  // How much did the pivot move?\n  dx = piv2.x - piv1.x\n  dy = piv2.y - piv1.y\n  tr1 = tr.translateBy(dx, dy)\n\n  // Now the pivot is on the grid.\n  // Let us then snap the scaling.\n  // Any change to the scale must be done around the pivot.\n  oldScale = tr1.getScale()\n  if (m.scaleStep === 0) {\n    newScale = oldScale // needed below\n  } else {\n    newScale = snap(oldScale, m.scaleStep, m.scalePhase)\n  }\n\n  scalingMultiplier = newScale / oldScale\n  tr2 = tr1.scaleBy(scalingMultiplier, piv2.toArray())\n\n  // After scaling, pivot stays the same.\n  // Let us rotate around the pivot.\n\n  oldRotation = tr2.getRotation()\n  if (m.rotateStep === 0) {\n    newRotation = oldRotation\n  } else {\n    // s = newScale * cos oldRotation\n    // r = newScale * sin oldRotation\n    // scale remains the same, only rotation changes\n    newRotation = snap(oldRotation, m.rotateStep, m.rotatePhase)\n  }\n\n  // We can use the same pivot because scaling is done so that\n  // it stays still.\n  return tr2.rotateBy(newRotation - oldRotation, piv2.toArray())\n}\n\nproto.toArray = function () {\n  return [this.mode]\n}\n\nproto.transform = function (tr) {\n  // Convert to another Grid\n  var tm = this.mode\n  var result = {} // transformed mode\n\n  var scale = tr.getScale()\n  var rotation = tr.getRotation()\n\n  // Rotation step is not affected at all.\n  // Rotation phase is affected by rotation.\n  result.rotateStep = tm.rotateStep\n  result.rotatePhase = tm.rotatePhase + rotation\n\n  // Scale step is probably (TODO) not affected at all.\n  // Scale phase however is affected by scaling.\n  // For example, let 1, 2, 3, 4 be allowed scalings on source.\n  // If target has x2 magnification, thus 2, 4, 6, and 8 are allowed.\n  // Another example, let 1.5, 2.5, and 3.5 be allowed scalings on source.\n  // Thus scaleStep = 1 and scalePhase = 0.5\n  // If target has x2 magnification, then 3, 5, and 7 are allowed.\n  // Thus scaleStep = 2 and scalePhase = 1 on the target.\n  result.scaleStep = tm.scaleStep * scale\n  result.scalePhase = tm.scalePhase * scale\n\n  if (tm.xStep === 0 || tm.yStep === 0) {\n    // No xy snapping\n    result.xStep = tm.xStep\n    result.yStep = tm.yStep\n    result.xRotation = tm.xRotation\n    result.yRotation = tm.yRotation\n    result.xPhase = tm.xPhase\n    result.yPhase = tm.yPhase\n  } else {\n    // Update grid basis vectors.\n    // Zero basis vectors do no trouble because they remain zero.\n    // xStep and yStep are altered by scale and rotation but not by translation.\n    // Represent step and rotation as Vector for easier transformation.\n    var gbx = Vector.createFromPolar(tm.xStep, tm.xRotation)\n    var gby = Vector.createFromPolar(tm.yStep, tm.yRotation)\n\n    // Transform the basis, but without translation\n    var trSR = tr.translateBy(-tr.tx, -tr.ty) // a bit dirty?\n    var xt = gbx.transform(trSR)\n    var yt = gby.transform(trSR)\n\n    result.xStep = xt.getMagnitude()\n    result.yStep = yt.getMagnitude()\n    result.xRotation = xt.getRotation()\n    result.yRotation = yt.getRotation()\n\n    // Transformation affects the phase.\n\n    // The xPhase/xStep and yPhase/yStep are coordinates on the grid\n    var normXPhase = tm.xPhase / tm.xStep\n    var normYPhase = tm.yPhase / tm.yStep\n    var normPhaseOnSourceGrid = new Vector(normXPhase, normYPhase)\n    var normPhaseOnSource = normPhaseOnSourceGrid.changeFromBasis(gbx, gby)\n    // Phase is about to change. Convert phase to the target plane.\n    var normPhaseOnTarget = normPhaseOnSource.transform(tr)\n    // And from the target plane to the new grid on the target plane.\n    var normPhaseOnTargetGrid = normPhaseOnTarget.changeBasis(xt, yt)\n    // Then undo the normalization.\n    var xPhaseOnTargetGrid = normPhaseOnTargetGrid.x * xt.getMagnitude()\n    var yPhaseOnTargetGrid = normPhaseOnTargetGrid.y * yt.getMagnitude()\n    // And store the result\n    result.xPhase = xPhaseOnTargetGrid\n    result.yPhase = yPhaseOnTargetGrid\n  }\n\n  return new Grid(result)\n}\n\nmodule.exports = Grid\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/Grid.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/IGrid.js":
/*!*************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/IGrid.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// Plane-Invariant Grid. Immutable.\n//\nvar IVector = __webpack_require__(/*! ./IVector */ \"./node_modules/tapspace/lib/geom/IVector.js\")\nvar IPath = __webpack_require__(/*! ./IPath */ \"./node_modules/tapspace/lib/geom/IPath.js\")\nvar ITransform = __webpack_require__(/*! ./ITransform */ \"./node_modules/tapspace/lib/geom/ITransform.js\")\nvar Grid = __webpack_require__(/*! ./Grid */ \"./node_modules/tapspace/lib/geom/Grid.js\")\n\nvar IGrid = function (grid, plane) {\n  // Example\n  //   var igrid = new tapspace.IGrid(grid, plane)\n  //\n  // Parameters\n  //   grid (optional, default to default Grid())\n  //     a Grid or a plain Grid step mode object\n  //   plane (optional, defaults to Space)\n  //     a AbstractPlane\n  //       an item in space, the plane of the grid.\n\n  if (typeof grid === 'undefined') {\n    this._grid = new Grid()\n  } else {\n    if (!grid.hasOwnProperty('mode')) {\n      // Step mode given\n      grid = new Grid(grid)\n    }\n\n    if (typeof plane === 'undefined') {\n      this._grid = grid\n    } else {\n      this._grid = grid.transform(plane.getGlobalTransform())\n    }\n  }\n}\n\nvar proto = IGrid.prototype\n\nproto.almostEqual = function (igrid) {\n  return this._grid.almostEqual(igrid._grid)\n}\n\nproto.at = function (x, y) {\n  return new IVector(this._grid.at(x, y))\n}\n\nproto.equal =\nproto.equals = function (igrid) {\n  // Return true if grids match.\n  return this._grid.equals(igrid._grid)\n}\n\nproto.getHullOf = function (x, y) {\n  var hull = this._grid.getHullOf(x, y)\n  return new IPath(hull)\n}\n\nproto.getOrigin = function () {\n  var orig = this._grid.getOrigin()\n  return new IVector(orig)\n}\n\nproto.snap = function (pivot, itr) {\n  // Parameters:\n  //   pivot\n  //     IVector\n  //   itr\n  //     ITransform\n  //\n  // Return\n  //   ITransform\n  //     The original transformed to snap to the grid.\n  //\n\n  // Grid requires that the pivot must be given on the source plane.\n  var piv = pivot.toSpace().transform(itr._tr.inverse())\n  return new ITransform(this._grid.snap(piv, itr._tr))\n}\n\nproto.to = function (plane) {\n  // Represent the grid on the target coordinate plane.\n  //\n  // Parameters\n  //   plane\n  //     a AbstractPlane\n  //\n  // Return\n  //   a Path\n  //\n  if (plane === null || plane.isRoot()) {\n    return this._grid\n  }\n\n  // Transformation from space to the target plane\n  var tr = plane.getGlobalTransform().inverse()\n  return this._grid.transform(tr)\n}\n\nproto.toSpace = function () {\n  // Represent the grid on the space coordinate plane.\n  //\n  // Return\n  //   a Grid.\n  //\n  return this._grid\n}\n\nproto.transform = function (itr) {\n  // Create a new IGrid by transforming this\n  // by invariant transformation.\n  //\n  // Parameters\n  //   itr\n  //     an ITransform\n  //\n  // Return\n  //   an IGrid\n  //\n  return new IGrid(this._grid.transform(itr._tr))\n}\n\nmodule.exports = IGrid\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/IGrid.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/IPath.js":
/*!*************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/IPath.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// Plane-Invariant Path. Immutable.\n//\nvar IVector = __webpack_require__(/*! ./IVector */ \"./node_modules/tapspace/lib/geom/IVector.js\")\nvar Path = __webpack_require__(/*! ./Path */ \"./node_modules/tapspace/lib/geom/Path.js\")\n\nvar IPath = function (p, plane) {\n  // Example\n  //   var ip = new tapspace.IPath(p, plane)\n  //\n  // Parameter\n  //   p (optional, default to empty Path())\n  //     a Path, a two-dimensional collection of Vectors\n  //   plane (optional, defaults to Space)\n  //     a AbstractPlane\n  //       an item in space, enabling coord projections.\n  //\n  if (typeof p === 'undefined') {\n    this._p = new Path()\n  } else if (typeof plane === 'undefined') {\n    this._p = p\n  } else {\n    this._p = p.transform(plane.getGlobalTransform())\n  }\n\n  this.length = this._p.length\n}\n\nvar proto = IPath.prototype\n\nproto.add = function (ip) {\n  // Create a new IPath by concatenating this and ipa.\n  //\n  // Parameters\n  //   ipa\n  //     an IPath\n  //\n  // Return\n  //   an IPath\n  //\n  return new IPath(this._p.add(ip._p))\n}\n\nproto.almostEqual = function (ipa) {\n  return this._p.almostEqual(ipa._p)\n}\n\nproto.atMid = function () {\n  return new IVector(this._p.atMid())\n}\n\nproto.bottom = function () {\n  console.warn('IPath#bottom is a deprecated method.')\n  return new IVector(this._p.bottom())\n}\n\nproto.equal =\nproto.equals = function (ipa) {\n  // Return true if paths match.\n  return this._p.equals(ipa._p)\n}\n\nproto.first = function () {\n  return new IVector(this._p.first())\n}\n\nproto.get = function (i) {\n  return new IVector(this._p.get(i))\n}\n\nproto.getBounds = function () {\n  console.warn('IPath#getBounds is a deprecated method.')\n  return new IPath(this._p.getBounds())\n}\n\nproto.getHull = function () {\n  // Return convex hull of the invariant path\n  return new IPath(this._p.getHull())\n}\n\nproto.last = function () {\n  return new IVector(this._p.last())\n}\n\nproto.left = function () {\n  console.warn('IPath#left is a deprecated method.')\n  return new IVector(this._p.left())\n}\n\nproto.right = function () {\n  console.warn('IPath#right is a deprecated method.')\n  return new IVector(this._p.right())\n}\n\nproto.to = function (plane) {\n  // Represent the path on the target coordinate plane.\n  //\n  // Parameters\n  //   plane: a AbstractPlane\n  //\n  // Return\n  //   a Path\n  //\n  if (plane === null || plane.isRoot()) {\n    return this._p\n  }\n\n  // Transformation from space to the target plane\n  var tr = plane.getGlobalTransform().inverse()\n  return this._p.transform(tr)\n}\n\nproto.toArray = function () {\n  // Return array of IVectors\n  return this._p.toArray().map(function (vec) {\n    return new IVector(vec)\n  })\n}\n\nproto.top = function () {\n  console.warn('IPath#right is a deprecated method.')\n  return new IVector(this._p.top())\n}\n\nproto.toSpace = function () {\n  // Represent the path on the space coordinate plane.\n  //\n  // Return\n  //   a Path.\n  //\n  return this._p\n}\n\nproto.transform = function (itr) {\n  // Create a new IPath by transforming this\n  // by invariant transformation.\n  //\n  // Parameters\n  //   itr\n  //     an ITransform\n  //\n  // Return\n  //   an IPath\n  return new IPath(this._p.transform(itr.toSpace()))\n}\n\nmodule.exports = IPath\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/IPath.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/IScalar.js":
/*!***************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/IScalar.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//\n// Plane-Invariant Scalar\n//\nvar IScalar = function (scalar, plane) {\n  // Example\n  //   var p = new tapspace.IScalar(scalar, plane);\n  //\n  // Parameter\n  //   scalar\n  //     a Number, a single real number\n  //   plane (optional, defaults to Space)\n  //     a AbstractPlane\n  //       an item in space, enabling coord projections.\n  //\n  if (typeof scalar !== 'number') {\n    throw new Error('a valid number is required')\n  }\n\n  if (typeof plane === 'undefined') {\n    this._num = scalar\n  } else {\n    this._num = scalar * plane.getGlobalTransform().getScale()\n  }\n}\n\nvar proto = IScalar.prototype\n\nproto.add = function (isca) {\n  // Create a new IScalar by adding this to isca.\n  //\n  // Parameters\n  //   isca\n  //     an IScalar\n  //\n  // Return\n  //   an IScalar\n  //\n  return new IScalar(this._num + isca._num)\n}\n\nproto.equal =\nproto.equals = function (isca) {\n  // Return true if invariant scalars match.\n  return this._num === isca._num\n}\n\nproto.multiply = function (factor) {\n  // See docs/api/\n  if (typeof factor === 'number') {\n    return new IScalar(this._num * factor)\n  }\n\n  return new IScalar(this._num * factor._num)\n}\n\nproto.subtract = function (isca) {\n  // Create a new IScalar by subtracting isca from this.\n  return new IScalar(this._num - isca._num)\n}\n\nproto.to = function (plane) {\n  // Represent the scalar on the target coordinate plane.\n  //\n  // Parameters\n  //   plane: a AbstractPlane\n  //\n  // Return\n  //   a Number\n  //\n  if (plane === null || plane.isRoot()) {\n    return this._num\n  }\n\n  // Transformation from space to the target plane\n  var s = plane.getGlobalTransform().inverse().getScale()\n  return this._num * s\n}\n\nproto.toSpace = function () {\n  // Represent the scalar on the space coordinate plane.\n  //\n  // Return\n  //   a Number\n  //\n  return this._num\n}\n\nmodule.exports = IScalar\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/IScalar.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/ISize.js":
/*!*************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/ISize.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var IScalar = __webpack_require__(/*! ./IScalar */ \"./node_modules/tapspace/lib/geom/IScalar.js\")\n\nvar ISize = function (size, plane) {\n  // Parameters:\n  //   size\n  //     a Size\n  //   plane\n  //     defines the coordinate system. Optional, default to root.\n  //\n  if (typeof size === 'undefined') {\n    throw new Error('Missing Size parameter')\n  }\n\n  if (typeof plane === 'undefined') {\n    this._size = size\n  } else {\n    this._size = size.transform(plane.getGlobalTransform())\n  }\n}\n\nvar proto = ISize.prototype\n\nproto.almostEqual = function (isize) {\n  return this._size.equal(isize._size)\n}\n\nproto.equal = function (isize) {\n  return this._size.equal(isize._size)\n}\n\nproto.getHeight = function () {\n  return new IScalar(this._size.height)\n}\n\nproto.getWidth = function () {\n  return new IScalar(this._size.width)\n}\n\nproto.to = function (plane) {\n  // Represent the size on the target coordinate plane.\n  //\n  // Parameters\n  //   plane: an AbstractPlane\n  //\n  // Return\n  //   a Size\n  //\n  if (plane === null || plane.isRoot()) {\n    return this._size\n  }\n\n  // Transformation from space to the target plane\n  var tr = plane.getGlobalTransform().inverse()\n  return this._size.transform(tr)\n}\n\nproto.toSpace = function () {\n  // Represent the size on the space coordinate plane.\n  //\n  // Return\n  //   a Size.\n  //\n  return this._size\n}\n\nmodule.exports = ISize\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/ISize.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/ITransform.js":
/*!******************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/ITransform.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\nPlane-Invariant Transform\n\nSimilarly as a point can be represented in multiple coordinate systems,\nso can a transformation. To prevent users from thinking about representations,\nwe have ITransform.\n\nITransform is a planeless representation of a transformation.\nThus, most exact name would be a coordinate-plane-invariant transformation.\n\n*/\nvar Transform = __webpack_require__(/*! ./Transform */ \"./node_modules/tapspace/lib/geom/Transform.js\")\nvar nudged = __webpack_require__(/*! nudged */ \"./node_modules/nudged/index.js\")\n\n// NOT YET USED ANYWHERE\n// var getTrBetweenPlanes = function (sourcePlane, targetPlane) {\n//   // Return a Transform that represents a mapping from sourcePlane\n//   // to the targetPlane.\n//   var source2space = sourcePlane.getGlobalTransform()\n//   var target2space = targetPlane.getGlobalTransform()\n//   return target2space.inverse().multiplyBy(source2space)\n// }\n\nvar getTrOnPlane = function (tr, trToPlane) {\n  // A same transformation can be represented on different coordinate systems.\n  // This fn takes a transformation tr on plane A and another transformation\n  // trToPlane from plane A to plane B. The result is a transformation\n  // that is globally equivalent to tr but represented on plane B.\n  //\n  // Parameters:\n  //   tr\n  //     a Transform on plane A\n  //   trToPlane\n  //     a Transform from plane A to plane B.\n  //     This is called a covariant transformation in math literature.\n  //\n  // Implementation note:\n  //   So, the resulting transformation tr' maps a vector X' to vector Y'\n  //   on plane B. The given transformation tr maps a vector X to vector Y\n  //   on plane A. Therefore, the raw approach is to:\n  //     1. map X' to X (= inverse of trToPlane)\n  //     2. map X to Y  (= tr)\n  //     3. map Y to Y' (= trToPlane)\n  //   Fortunately we can combine the mappings.\n  return trToPlane.multiplyBy(tr.multiplyBy(trToPlane.inverse()))\n}\n\nvar ITransform = function (transf, plane) {\n  // Immutable i.e. new instances are returned.\n  //\n  // Example\n  //   var t = new tapspace.ITransform(tr, pixel)\n  //\n  // Parameter\n  //   transf\n  //     Optional. A tapspace.Transform. Default to identity transform.\n  //   plane\n  //     An optional AbstractPlane. Defaults to space.\n  //       an item in space, gives the reference plane of transf.\n  //\n  // Design note:\n  //   fn (transf, plane) has this parameter order to make difference\n  //   to AbstractNodes' (parent, prop1, prop2, ...)\n\n  // DEBUG\n  if (plane && !('_T' in plane)) {\n    throw new Error('invalid reference')\n  }\n  if (transf && !transf.hasOwnProperty('tx')) {\n    throw new Error('invalid transform')\n  }\n\n  // transf is the transformation on the plane.\n  if (typeof transf === 'undefined') { transf = Transform.IDENTITY }\n\n  if (plane) {\n    // Convert transformation to space\n    this._tr = getTrOnPlane(transf, plane.getGlobalTransform())\n  } else {\n    // transf already in space\n    this._tr = transf\n  }\n}\n\nvar proto = ITransform.prototype\n\nproto.almostEqual =\nproto.almostEquals = function (gt) {\n  // See Transform.almostEqual\n  return this._tr.almostEqual(gt._tr)\n}\n\nproto.equal =\nproto.equals = function (gt) {\n  // Test if given ITransform represents equivalent transformation\n  // regardless of reference.\n  //\n  // Parameters:\n  //   gt\n  //     an ITransform\n\n  return this._tr.equals(gt._tr)\n}\n\nproto.inverse = function () {\n  // Return inversed transformation.\n  return new ITransform(this._tr.inverse())\n}\n\nproto.to = function (plane) {\n  // Represent the transform on the target coordinate plane.\n  //\n  // Parameters:\n  //   plane: a AbstractPlane\n  //\n  // Return:\n  //   a Transform\n  //\n  if (plane === null || plane.isRoot()) {\n    // Is Space\n    return this._tr\n  }\n\n  // Transformation from space to the target plane\n  var covTr = plane.getGlobalTransform().inverse()\n  return getTrOnPlane(this._tr, covTr)\n}\n\nproto.toSpace = function () {\n  // Represent the transform on the space coordinate plane.\n  //\n  // Return a Transform.\n  //\n  return this._tr\n}\n\nproto.multiplyRight =\nproto.multiplyBy =\nproto.transformBy = function (itr) {\n  // Transform the image of this by given ITransform.\n  //\n  // Parameters:\n  //   itr\n  //     an ITransform\n  //\n  return new ITransform(itr._tr.multiplyBy(this._tr))\n}\n\nproto.relativeTo = function (itr) {\n  // Return an ITransform T that when multiplied from right\n  // i.e. applied to itr, produces self:\n  //   self = T * itr\n  //  <=> T = self * inv(itr)\n  //\n  // Parameters:\n  //   itr\n  //     ITransform\n  //\n  return new ITransform(this._tr.multiplyBy(itr._tr.inverse()))\n}\n\nproto.translate = function (domain, range) {\n  // Move transform image horizontally and vertically with control points.\n  //\n  // Translate so that after the translation, the domain points\n  // would be as close to given range points as possible.\n  //\n  // Parameters:\n  //   domain: array of IVector\n  //   range: array of IVector\n  //\n  // Return:\n  //   an ITransform\n  //\n  var itr = ITransform.estimate('T', domain, range)\n  return itr.multiplyRight(this)\n}\n\nproto.scale = function (pivot, multiplierOrDomain, range) {\n  // Parameters:\n  //   pivot: a IVector\n  //   multiplier: the scale factor, > 0\n  //  OR\n  //   pivot: a IVector\n  //   domain: array of IVector\n  //   range: array of IVector\n  var useMultiplier, normPivot, domain, multiplier, tr, itr\n\n  useMultiplier = (typeof range === 'undefined')\n\n  if (useMultiplier) {\n    normPivot = pivot.toSpace().toArray()\n    multiplier = multiplierOrDomain\n    // Multiplier does not depend on plane.\n    tr = this._tr.scaleBy(multiplier, normPivot)\n    return new ITransform(tr)\n  } else {\n    domain = multiplierOrDomain\n    itr = ITransform.estimate('S', domain, range, pivot)\n    return itr.multiplyBy(this)\n  }\n}\n\nproto.rotate = function (pivot, radiansOrDomain, range) {\n  // Parameters:\n  //   pivot: a IVector\n  //   radians: rotation angle\n  //  OR\n  //   pivot: a IVector\n  //   domain: array of IVector\n  //   range: array of IVector\n  var useRadians, normPivot, domain, radians, tr, itr\n\n  useRadians = (typeof range === 'undefined')\n\n  if (useRadians) {\n    normPivot = pivot.toSpace().toArray()\n    radians = radiansOrDomain\n    // Radians do not depend on plane.\n    tr = this._tr.rotateBy(radians, normPivot)\n    return new ITransform(tr)\n  } else {\n    domain = radiansOrDomain\n    itr = ITransform.estimate('R', domain, range, pivot)\n    return itr.multiplyBy(this)\n  }\n}\n\nproto.translateScale = function (domain, range) {\n  // Parameters:\n  //   domain: array of IVector\n  //   range: array of IVector\n  var itr = ITransform.estimate('TS', domain, range)\n  return itr.multiplyBy(this)\n}\n\nproto.translateRotate = function (domain, range) {\n  // Parameters:\n  //   domain: array of IVector\n  //   range: array of IVector\n  var itr = ITransform.estimate('TR', domain, range)\n  return itr.multiplyBy(this)\n}\n\nproto.scaleRotate = function (pivot, domain, range) {\n  // Parameters:\n  //   pivot: IVector\n  //   domain: array of IVector\n  //   range: array of IVector\n  var itr = ITransform.estimate('SR', domain, range, pivot)\n  return itr.multiplyBy(this)\n}\n\nproto.translateScaleRotate = function (domain, range) {\n  // Parameters:\n  //   domain: array of IVector\n  //   range: array of IVector\n  var itr = ITransform.estimate('TSR', domain, range)\n  return itr.multiplyBy(this)\n}\n\n// Class methods\n\nITransform.IDENTITY = new ITransform()\n\nITransform.estimate = function (type, domain, range, pivot) {\n  // Estimate ITransform from control points.\n  //\n  // Parameters:\n  //   type: transformation type.\n  //     Available types: T,S,R,TS,TR,SR,TSR (see nudged for further details)\n  //   domain\n  //     IPath or array of IVector\n  //   range\n  //     IPath or array of IVector\n  //   pivot\n  //     IVector, an optional pivot, used with types S,R,SR\n  //\n  var normPivot, normDomain, normRange, tr\n\n  if (typeof pivot !== 'undefined') {\n    normPivot = pivot.toSpace().toArray()\n  }\n\n  // Allow singles & IPaths\n  if (domain.hasOwnProperty('_vec')) {\n    domain = [domain]\n  } else if (domain.hasOwnProperty('_p')) {\n    domain = domain.toArray()\n  }\n\n  if (range.hasOwnProperty('_vec')) {\n    range = [range]\n  } else if (range.hasOwnProperty('_p')) {\n    range = range.toArray()\n  }\n\n  // Convert all IVectors onto the plane and to arrays\n  var piv2arr = function (iv) {\n    return [iv._vec.x, iv._vec.y]\n  }\n  normDomain = domain.map(piv2arr)\n  normRange = range.map(piv2arr)\n\n  // Then compute optimal transformation on the plane\n  tr = nudged.estimate(type, normDomain, normRange, normPivot)\n  return new ITransform(tr)\n}\n\nmodule.exports = ITransform\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/ITransform.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/IVector.js":
/*!***************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/IVector.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// Plane-Invariant Vector. A Vector can be represented in different\n// coordinate systems. The IVector frees the user from\n// thinking the coordinate system of the vector.\n//\nvar Vector = __webpack_require__(/*! ./Vector */ \"./node_modules/tapspace/lib/geom/Vector.js\")\nvar IScalar = __webpack_require__(/*! ./IScalar */ \"./node_modules/tapspace/lib/geom/IScalar.js\")\n\nvar IVector = function (vec, plane) {\n  // Example\n  //   var p = new tapspace.IVector(vec, plane)\n  //\n  // Parameter\n  //   vec\n  //     a Vector, two-dimensional vector\n  //   plane (optional, defaults to Space)\n  //     a AbstractPlane\n  //       an item in space, enabling coord projections.\n  //\n  // Design note:\n  //   fn (vec, plane) in this order to differentiate from AbstractNodes.\n  //   The first argument of AbstractNodes is the parent.\n  //\n  if (typeof vec === 'undefined') {\n    throw new Error('a Vector is required')\n  }\n\n  if (typeof plane === 'undefined') {\n    this._vec = vec\n  } else {\n    this._vec = vec.transform(plane.getGlobalTransform())\n  }\n\n  // Design note: at first, the references were AbstractPlanes and not\n  // transformations. But because a AbstractPlane can move or be removed,\n  // we chose only the transformation to be remembered.\n  // Design note: later we found it would be convenient for debugging\n  // to know where the point came from, which led to this._origin.\n  // After that we found that in toSpace method, we would need reference\n  // to space, although we only have implicit reference to its coords.\n  // Therefore this._origin was dropped.\n\n  // Design note: was previously SpacePoint but it felt wrong to\n  // require users to know the plane the SpacePoint was in. The initial\n  // reason for SpacePoint was to get rid of that knowledge requirement.\n  // IVector is a Point without a plane. Internally the coordinates\n  // are represented on the space plane for now.\n}\n\nIVector.mean = function (ivlist) {\n  // Average of the listed IVectors.\n  //\n  var i\n  var len = ivlist.length\n  var sumx = 0\n  var sumy = 0\n  if (len > 0) {\n    for (i = 0; i < len; i += 1) {\n      sumx += ivlist[i]._vec.x\n      sumy += ivlist[i]._vec.y\n    }\n    return new IVector(new Vector(sumx / len, sumy / len))\n  }\n  throw new Error('Cannot compute mean for an empty list of ivectors.')\n}\n\nvar proto = IVector.prototype\n\nproto.add = function (ivec) {\n  // Create a new IVector by adding this to ivec.\n  //\n  // Parameters\n  //   ivec\n  //     an IVector, displacement vector\n  //\n  // Return\n  //   an IVector\n  //\n  return new IVector(this._vec.add(ivec._vec))\n}\n\nproto.almostEqual = function (ivec) {\n  return this._vec.almostEqual(ivec._vec)\n}\n\nproto.distance = function (ivec) {\n  // Return distance between two IVectors i.e.\n  // norm of their difference as IScalar.\n  return new IScalar(this._vec.distance(ivec._vec))\n}\n\nproto.equal =\nproto.equals = function (ivec) {\n  // Return true if invariant vectors match.\n  return this._vec.equals(ivec._vec)\n}\n\nproto.multiply = function (scalar) {\n  return new IVector(this._vec.multiply(scalar))\n}\n\nproto.norm = function () {\n  // Return\n  //   an IScalar\n  return new IScalar(this._vec.norm())\n}\n\nproto.offset = function (dx, dy, plane) {\n  // Create a new vector displaced by dx and dy.\n  //\n  // Parameters\n  //   dx\n  //   dy\n  //   plane\n  //     an optional plane of dx and dy. Default to space.\n  //\n  // Return\n  //   an IVector\n  //\n  var dv, spacev\n  dv = new Vector(dx, dy)\n\n  if (plane) {\n    spacev = dv.transform(plane.getGlobalTransform())\n  } else {\n    spacev = dv\n  }\n\n  return new IVector(this._vec.add(spacev))\n}\n\nproto.polarOffset = function (radius, radians, plane) {\n  // Create a new point moved by the polar coordinates\n  //\n  // Parameters:\n  //   radius\n  //     number or IScalar, the distance from the vector\n  //   radians\n  //     rotation angle\n  //   plane\n  //     optional plane of the offset.\n  //     The global rotation of the plane affects the angle.\n  //     The global scale of the plane affects the radius.\n  //\n  // Return\n  //   an IVector\n  //\n  var dx, dy, dv, gt\n\n  if (typeof radius !== 'number') {\n    if (plane) {\n      radius = radius.to(plane)\n    } else {\n      radius = radius.toSpace()\n    }\n  }\n\n  // Transform to root coordinates.\n  // Do not translate because translation should not affect radius.\n  if (plane) {\n    gt = plane.getGlobalTransform()\n    radius = radius * gt.getScale()\n    radians = radians + gt.getRotation()\n  }\n\n  dx = radius * Math.cos(radians)\n  dy = radius * Math.sin(radians)\n  dv = new Vector(dx, dy)\n\n  return new IVector(this._vec.add(dv))\n}\n\nproto.to = function (plane) {\n  // Represent the vector on the target coordinate plane.\n  //\n  // Parameters\n  //   plane: a AbstractPlane\n  //\n  // Return\n  //   a Vector\n  //\n  if (plane === null || plane.isRoot()) {\n    return this._vec\n  }\n\n  // Transformation from space to the target plane\n  var tr = plane.getGlobalTransform().inverse()\n  return this._vec.transform(tr)\n}\n\nproto.toSpace = function () {\n  // Represent the vector on the space coordinate plane.\n  //\n  // Return\n  //   a Vector.\n  //\n  return this._vec\n}\n\nproto.transform = function (itr) {\n  // Create a new vector by transforming this by invariant transformation.\n  //\n  // Parameters\n  //   itr\n  //     an ITransform\n  //\n  // Return\n  //   an IVector\n  return new IVector(this._vec.transform(itr.toSpace()))\n}\n\nmodule.exports = IVector\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/IVector.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/Path.js":
/*!************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/Path.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n// Immutable container for Vectors\n//\nvar Vector = __webpack_require__(/*! ./Vector */ \"./node_modules/tapspace/lib/geom/Vector.js\")\nvar EPSILON = __webpack_require__(/*! ./epsilon */ \"./node_modules/tapspace/lib/geom/epsilon.js\")\nvar convexHull = __webpack_require__(/*! monotone-convex-hull-2d */ \"./node_modules/monotone-convex-hull-2d/index.js\")\n\nvar Path = function (segments) {\n  if (typeof segments === 'undefined') {\n    segments = []\n  }\n  this._seg = segments\n  this.length = segments.length\n}\n\nvar proto = Path.prototype\n\nproto.add = function (p) {\n  // Parameters:\n  //   path\n  //  OR\n  //   vector\n  //\n  // Return\n  //   new Path\n\n  if (p.hasOwnProperty('_seg')) {\n    // Path\n    return new Path(this._seg.concat(p._seg))\n  } else if (p.hasOwnProperty('x')) {\n    // Vector\n    return new Path(this._seg.concat([p]))\n  }\n\n  throw new Error('Invalid Path or Vector')\n}\n\nproto.almostEqual = function (p) {\n  // Test if two paths are equal\n  if (this._seg.length === p._seg.length) {\n    for (var i = 0; i < this._seg.length; i += 1) {\n      if (!this._seg[i].almostEqual(p._seg[i])) {\n        return false\n      }\n    }\n    return true\n  }\n  return false\n}\n\nproto.atMid = function () {\n  // Mass centroid of the closed path.\n  // The result is valid only if the path is non-self-intersecting.\n  //\n  // Return\n  //   Vector\n  //   null\n  //     if empty path\n  //\n  // Source:\n  //   https://en.wikipedia.org/wiki/Centroid\n  //   2018-01-16\n  //\n  var i, d\n  var s = this._seg\n  var cx = 0\n  var cy = 0\n  var area = 0\n\n  if (s.length === 0) {\n    return null\n  }\n\n  if (s.length === 1) {\n    return this._seg[0]\n  }\n\n  for (i = 0; i + 1 < s.length; i += 1) {\n    d = (s[i].x * s[i + 1].y) - (s[i + 1].x * s[i].y)\n    cx += (s[i].x + s[i + 1].x) * d\n    cy += (s[i].y + s[i + 1].y) * d\n    area += d\n  }\n\n  // Close the path\n  // i + 1 === s.length\n  d = (s[i].x * s[0].y - s[0].x * s[i].y)\n  cx += (s[i].x + s[0].x) * d\n  cy += (s[i].y + s[0].y) * d\n  area += d\n\n  // Area might be zero. For example, consider lines.\n  // If so, return mean of points.\n  if (Math.abs(area) < EPSILON) {\n    cx = 0\n    cy = 0\n    for (i = 0; i < s.length; i += 1) {\n      cx += s[i].x\n      cy += s[i].y\n    }\n    return new Vector(cx / s.length, cy / s.length)\n  }\n\n  // Normalize\n  area *= 0.5\n  cx *= 1 / (6 * area)\n  cy *= 1 / (6 * area)\n\n  return new Vector(cx, cy)\n}\n\nproto.bottom = function () {\n  var maxv, i\n\n  if (this._seg.length === 0) {\n    return null\n  }\n\n  maxv = this._seg[0]\n\n  for (i = 1; i < this._seg.length; i += 1) {\n    if (this._seg[i].y > maxv.y) {\n      maxv = this._seg[i]\n    }\n  }\n\n  return maxv\n}\n\nproto.equal =\nproto.equals = function (p) {\n  // Test if two paths are equal\n  if (this._seg.length === p._seg.length) {\n    for (var i = 0; i < this._seg.length; i += 1) {\n      if (!this._seg[i].equals(p._seg[i])) {\n        return false\n      }\n    }\n    return true\n  }\n  return false\n}\n\nproto.first = function () {\n  if (this._seg.length > 0) {\n    return this._seg[0]\n  }\n  return null\n}\n\nproto.get = function (i) {\n  // Get i:th element\n  return this._seg[i]\n}\n\nproto.getBounds = function () {\n  // Get bounding box of the path.\n  // Return rectangular Path with following path segment vectors.\n  //\n  // [0]-----[3]\n  //  |       |\n  // [1]-----[2]\n  //\n  var minx, miny, maxx, maxy, i, v\n\n  if (this._seg.length === 0) {\n    return null\n  }\n\n  v = this._seg[0]\n  minx = v.x\n  miny = v.y\n  maxx = v.x\n  maxy = v.y\n\n  for (i = 1; i < this._seg.length; i += 1) {\n    v = this._seg[i]\n    minx = Math.min(minx, v.x)\n    miny = Math.min(miny, v.y)\n    maxx = Math.max(maxx, v.x)\n    maxy = Math.max(maxy, v.y)\n  }\n\n  return new Path([\n    new Vector(minx, miny),\n    new Vector(minx, maxy),\n    new Vector(maxx, maxy),\n    new Vector(maxx, miny)\n  ])\n}\n\nproto.getHull = function () {\n  // Get convex hull of the path. Counter-clockwise.\n  //\n  // Return\n  //   a Path\n  //\n  if (this._seg.length < 1) {\n    return this\n  }\n\n  var indices = convexHull(this._seg.map(function (vec) {\n    return vec.toArray()\n  }))\n\n  // The convexHull returns the points in clockwise order\n  // but assumes positive y to head up. In web browsers,\n  // positive y heads down and thus convexHull returns\n  // them in counterclockwise order.\n  var seq = indices.map(function (i) {\n    return this._seg[i]\n  }, this)\n\n  return new Path(seq)\n}\n\nproto.last = function () {\n  if (this._seg.length > 0) {\n    return this._seg[this._seg.length - 1]\n  }\n  return null\n}\n\nproto.left = function () {\n  // Leftmost seqment Vector. Return first leftmost if many.\n  var minv, i\n\n  if (this._seg.length === 0) {\n    return null\n  }\n\n  minv = this._seg[0]\n\n  for (i = 1; i < this._seg.length; i += 1) {\n    if (this._seg[i].x < minv.x) {\n      minv = this._seg[i]\n    }\n  }\n\n  return minv\n}\n\nproto.right = function () {\n  var maxv, i\n\n  if (this._seg.length === 0) {\n    return null\n  }\n\n  maxv = this._seg[0]\n\n  for (i = 1; i < this._seg.length; i += 1) {\n    if (this._seg[i].x > maxv.x) {\n      maxv = this._seg[i]\n    }\n  }\n\n  return maxv\n}\n\nproto.toArray = function () {\n  return this._seg\n}\n\nproto.top = function () {\n  var minv, i\n\n  if (this._seg.length === 0) {\n    return null\n  }\n\n  minv = this._seg[0]\n\n  for (i = 1; i < this._seg.length; i += 1) {\n    if (this._seg[i].y < minv.y) {\n      minv = this._seg[i]\n    }\n  }\n\n  return minv\n}\n\nproto.transform = function (tr) {\n  // Multiply the Path segment vectors from left\n  //\n  // Parameters:\n  //   tr\n  //     a Transform\n  //\n  // Return\n  //   new Path\n  //\n  var seg = this._seg.map(function (vec) {\n    return vec.transform(tr)\n  })\n  return new Path(seg)\n}\n\nmodule.exports = Path\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/Path.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/Size.js":
/*!************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/Size.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var EPSILON = __webpack_require__(/*! ./epsilon */ \"./node_modules/tapspace/lib/geom/epsilon.js\")\n\nvar Size = function (width, height) {\n  // Parameters:\n  //   width\n  //     number, must be 0 or positive\n  //   height\n  //     number, must be 0 or positive\n  //\n  if (typeof width !== 'number' || typeof height !== 'number') {\n    throw new Error('Missing or invalid (width, height) parameters')\n  }\n  if (width < 0 || height < 0) {\n    throw new Error('Width and height must be zero or positive.')\n  }\n\n  this.width = width\n  this.height = height\n}\n\nvar proto = Size.prototype\n\nproto.almostEqual = function (size) {\n  return Math.abs(this.width - size.width) +\n    Math.abs(this.height - size.height) < EPSILON\n}\n\nproto.equal = function (size) {\n  return (this.width === size.width && this.height === size.height)\n}\n\nproto.getHeight = function () {\n  return this.height\n}\n\nproto.getWidth = function () {\n  return this.width\n}\n\nproto.toArray = function () {\n  return [this.width, this.height]\n}\n\nproto.transform = function (tr) {\n  // Transform the Size. Only scaling affects to the size.\n  //\n  // Parameters:\n  //   tr\n  //     a Transform\n  //\n  var s = tr.getScale()\n  var w = this.width * s\n  var h = this.height * s\n  return new Size(w, h)\n}\n\nmodule.exports = Size\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/Size.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/Transform.js":
/*!*****************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/Transform.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar nudged = __webpack_require__(/*! nudged */ \"./node_modules/nudged/index.js\")\n\nmodule.exports = nudged.Transform\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/Transform.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/Vector.js":
/*!**************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/Vector.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var EPSILON = __webpack_require__(/*! ./epsilon */ \"./node_modules/tapspace/lib/geom/epsilon.js\")\n\nvar Vector = function (x, y) {\n  if (typeof y === 'undefined') {\n    throw new Error('Missing (x, y) parameters')\n  }\n  this.x = x\n  this.y = y\n}\n\nVector.createFromPolar = function (magnitude, direction) {\n  // Parameters\n  //   magnitude\n  //     number\n  //   direction\n  //     number, angle in radians\n  //\n  return new Vector(\n    magnitude * Math.cos(direction),\n    magnitude * Math.sin(direction)\n  )\n}\n\nVector.mean = function (vlist) {\n  // Average of the listed Vectors.\n  //\n  var i\n  var len = vlist.length\n  var sumx = 0\n  var sumy = 0\n  if (len > 0) {\n    for (i = 0; i < len; i += 1) {\n      sumx += vlist[i].x\n      sumy += vlist[i].y\n    }\n    return new Vector(sumx / len, sumy / len)\n  }\n  throw new Error('Cannot compute mean for an empty list of vectors.')\n}\n\nvar proto = Vector.prototype\n\nproto.add = function (vec) {\n  return new Vector(this.x + vec.x, this.y + vec.y)\n}\n\nproto.almostEqual = function (v) {\n  return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) < EPSILON\n}\n\nproto.changeBasis = function (vi, vj) {\n  // Change of basis given new basis vectors.\n  // The returned vector becomes represented in a coordinate space\n  // where vi and vj are the basis vectors.\n  //\n  // Let vx and vy be current basis vectors.\n  // Let a*vx + b*vy = c*vi + d*vj\n  // Let vi = g*vx + f*vy\n  // Let vj = h*vx + k*vy\n  // Let vx = (1,0), vy = (0,1)\n  //\n  // Solve for c, d.\n  //   (a, b) = c*g*(1,0) + c*f*(0,1) + d*h*(1,0) + d*k*(0,1)\n  //          = (c*g + d*h, c*f + d*k)\n  //\n  //   c = (b*h - a*k) / (f*h - g*k)\n  //   d = (a*f - b*g) / (f*h - g*k)\n  //\n  // Note\n  //   a = this.x\n  //   b = this.y\n  //   g = vi.x\n  //   f = vi.y\n  //   h = vj.x\n  //   k = vj.y\n  //\n\n  // (f*h - g*k) != 0\n  var denom = vi.y * vj.x - vi.x * vj.y\n  if (Math.abs(denom) < EPSILON) {\n    throw new Error('Basis vectors must be linearly independent.')\n  }\n\n  return new Vector(\n    (this.y * vj.x - this.x * vj.y) / denom,\n    (this.x * vi.y - this.y * vi.x) / denom\n  )\n}\n\nproto.changeFromBasis = function (vi, vj) {\n  // Opposite of changeBasis:\n  //   vb = v.changeBasis(vi, vj)\n  //   v === vb.changeFromBasis(vi, vj)\n  //\n  // Equivalent to\n  //   this.changeBasis(\n  //     (new Vector(1, 0)).changeBasis(vi, vj),\n  //     (new Vector(0, 1)).changeBasis(vi, vj)\n  //   )\n  //\n  // Simple to solve:\n  //   this.x is the number of vi vectors and\n  //   this.y is the number of vj vectors.\n  //   Therefore result is this.x * vi + this.y * vj\n  //\n  var denom = vi.y * vj.x - vi.x * vj.y\n  if (Math.abs(denom) < EPSILON) {\n    throw new Error('Basis vectors must be linearly independent.')\n  }\n\n  return new Vector(\n    this.x * vi.x + this.y * vj.x,\n    this.x * vi.y + this.y * vj.y\n  )\n}\n\nproto.distance = function (vec) {\n  var dx = this.x - vec.x\n  var dy = this.y - vec.y\n  return Math.sqrt(dx * dx + dy * dy)\n}\n\nproto.equal =\nproto.equals = function (vec) {\n  return (this.x === vec.x && this.y === vec.y)\n}\n\nproto.getRotation = function () {\n  return Math.atan2(this.y, this.x)\n}\n\nproto.getMagnitude = function () {\n  return Math.sqrt(this.x * this.x + this.y * this.y)\n}\n\nproto.isIndependent = function (v) {\n  // Return true if the two vectors are linearly independent.\n  return this.x * v.y - this.y * v.x !== 0\n}\n\nproto.opposite = function () {\n  return new Vector(-this.x, -this.y)\n}\n\nproto.max = function (vec) {\n  // Maximum of two vectors\n  var x = Math.max(this.x, vec.x)\n  var y = Math.max(this.y, vec.y)\n  return new Vector(x, y)\n}\n\nproto.min = function (vec) {\n  // Minimum of two vectors\n  var x = Math.min(this.x, vec.x)\n  var y = Math.min(this.y, vec.y)\n  return new Vector(x, y)\n}\n\nproto.multiply = function (scalar) {\n  return new Vector(this.x * scalar, this.y * scalar)\n}\n\nproto.norm = function () {\n  return Math.sqrt(this.x * this.x + this.y * this.y)\n}\n\nproto.translate =\nproto.offset = function (dx, dy) {\n  // Cartesian offset\n  return new Vector(this.x + dx, this.y + dy)\n}\n\nproto.polarOffset = function (radius, radians) {\n  // Create a new Vector where the point is moved by the polar coordinates\n  //\n  // Parameters:\n  //   radius\n  //   radians\n  var x = this.x + radius * Math.cos(radians)\n  var y = this.y + radius * Math.sin(radians)\n  return new Vector(x, y)\n}\n\nproto.rotate = function (radians) {\n  // Rotate about (0, 0)\n  var x = this.x * Math.cos(radians) - this.y * Math.sin(radians)\n  var y = this.x * Math.sin(radians) + this.y * Math.cos(radians)\n  return new Vector(x, y)\n}\n\nproto.subtract = function (vec) {\n  return new Vector(this.x - vec.x, this.y - vec.y)\n}\n\nproto.toArray = function () {\n  return [this.x, this.y]\n}\n\nproto.transform = function (tr) {\n  // Multiply the vector from left: result = tr * this\n  //\n  // Parameters:\n  //   tr\n  //     a Transform\n  //\n  var x = this.x * tr.s - this.y * tr.r + tr.tx\n  var y = this.x * tr.r + this.y * tr.s + tr.ty\n  return new Vector(x, y)\n}\n\nmodule.exports = Vector\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/Vector.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/epsilon.js":
/*!***************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/epsilon.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./Transform */ \"./node_modules/tapspace/lib/geom/Transform.js\").EPSILON\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/epsilon.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/geom/index.js":
/*!*************************************************!*\
  !*** ./node_modules/tapspace/lib/geom/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.EPSILON = __webpack_require__(/*! ./epsilon */ \"./node_modules/tapspace/lib/geom/epsilon.js\")\n\nexports.Grid = __webpack_require__(/*! ./Grid */ \"./node_modules/tapspace/lib/geom/Grid.js\")\nexports.IGrid = __webpack_require__(/*! ./IGrid */ \"./node_modules/tapspace/lib/geom/IGrid.js\")\n\nexports.Path = __webpack_require__(/*! ./Path */ \"./node_modules/tapspace/lib/geom/Path.js\")\nexports.IPath = __webpack_require__(/*! ./IPath */ \"./node_modules/tapspace/lib/geom/IPath.js\")\n\nexports.IScalar = __webpack_require__(/*! ./IScalar */ \"./node_modules/tapspace/lib/geom/IScalar.js\")\n\nexports.Size = __webpack_require__(/*! ./Size */ \"./node_modules/tapspace/lib/geom/Size.js\")\nexports.ISize = __webpack_require__(/*! ./ISize */ \"./node_modules/tapspace/lib/geom/ISize.js\")\n\nexports.Transform = __webpack_require__(/*! ./Transform */ \"./node_modules/tapspace/lib/geom/Transform.js\")\nexports.ITransform = __webpack_require__(/*! ./ITransform */ \"./node_modules/tapspace/lib/geom/ITransform.js\")\n\nexports.Vector = __webpack_require__(/*! ./Vector */ \"./node_modules/tapspace/lib/geom/Vector.js\")\nexports.IVector = __webpack_require__(/*! ./IVector */ \"./node_modules/tapspace/lib/geom/IVector.js\")\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/geom/index.js?");

/***/ }),

/***/ "./node_modules/tapspace/lib/version.js":
/*!**********************************************!*\
  !*** ./node_modules/tapspace/lib/version.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// generated by genversion\nmodule.exports = '1.5.2'\n\n\n//# sourceURL=webpack:///./node_modules/tapspace/lib/version.js?");

/***/ }),

/***/ "./node_modules/two-product/two-product.js":
/*!*************************************************!*\
  !*** ./node_modules/two-product/two-product.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = twoProduct\n\nvar SPLITTER = +(Math.pow(2, 27) + 1.0)\n\nfunction twoProduct(a, b, result) {\n  var x = a * b\n\n  var c = SPLITTER * a\n  var abig = c - a\n  var ahi = c - abig\n  var alo = a - ahi\n\n  var d = SPLITTER * b\n  var bbig = d - b\n  var bhi = d - bbig\n  var blo = b - bhi\n\n  var err1 = x - (ahi * bhi)\n  var err2 = err1 - (alo * bhi)\n  var err3 = err2 - (ahi * blo)\n\n  var y = alo * blo - err3\n\n  if(result) {\n    result[0] = y\n    result[1] = x\n    return result\n  }\n\n  return [ y, x ]\n}\n\n//# sourceURL=webpack:///./node_modules/two-product/two-product.js?");

/***/ }),

/***/ "./node_modules/two-sum/two-sum.js":
/*!*****************************************!*\
  !*** ./node_modules/two-sum/two-sum.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = fastTwoSum\n\nfunction fastTwoSum(a, b, result) {\n\tvar x = a + b\n\tvar bv = x - a\n\tvar av = x - bv\n\tvar br = b - bv\n\tvar ar = a - av\n\tif(result) {\n\t\tresult[0] = ar + br\n\t\tresult[1] = x\n\t\treturn result\n\t}\n\treturn [ar+br, x]\n}\n\n//# sourceURL=webpack:///./node_modules/two-sum/two-sum.js?");

/***/ }),

/***/ "./src/goldenlion.ejs":
/*!****************************!*\
  !*** ./src/goldenlion.ejs ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (obj) {\nobj || (obj = {});\nvar __t, __p = '';\nwith (obj) {\n__p += '<span style=\"color: gold\">THE GOLDEN LION</span>\\n\\nSABOR, the lioness, suckled her young—a single fuzzy ball,\\nspotted like Sheeta, the leopard. She lay in the warm\\nsunshine before the rocky cavern that was her lair, stretched\\nout upon her side with half closed eyes, yet Sabor was alert.\\nThere had been three of these little, fuzzy balls at first—two\\ndaughters and a son—and Sabor and Numa, their sire, had\\nbeen proud of them; proud and happy. But kills had not been\\nplentiful, and Sabor, undernourished, had been unable to\\nproduce sufficient milk to nourish properly three lusty cubs,\\nand then a cold rain had come, and the little ones had sickened.\\nOnly the strongest survived—the two daughters had died.\\nSabor had mourned, pacing to and fro beside the pitiful bits of\\nbedraggled fur, whining and moaning. Now and again she\\nwould nose them with her muzzle as though she would awaken\\nthem from the long sleep that knows no waking. At last,\\nhowever, she abandoned her efforts, and now her whole savage\\nheart was filled with concern for the little male cub that\\nremained to her. That was why Sabor was more alert than\\nusual.<br>\\n\\n&nbsp;&nbsp;&nbsp;&nbsp;Numa, the lion, was away. Two nights before he had made\\na kill and dragged it to their lair and last night he had fared\\nforth again, but he had not returned. Sabor was thinking, as she\\nhalf dozed, of Wappi, the plump antelope, that her splendid\\nmate might this very minute be dragging through the tangled\\njungle to her. Or perhaps it would be Pacco, the zebra, whose\\nflesh was the best beloved of her kind—juicy, succulent Pacco.\\nSabor’s mouth watered.\\n\\n&nbsp;&nbsp;&nbsp;&nbsp;Ah, what was that? The shadow of a sound had come to\\nthose keen ears. She raised her head, cocking it first upon one\\nside and then the other, as with up-pricked ears she sought to\\ncatch the faintest repetition of that which had disturbed her.\\nHer nose sniffed the air. There was but the suggestion of a\\nbreeze, but what there was moved toward her from the\\ndirection of the sound she had heard, and which she still heard\\nin a slightly increasing volume that told her that whatever was\\nmaking it was approaching her. As it drew closer the beast\\'s\\nnervousness increased and she rolled over on her belly,\\nshutting off the milk supply from the cub, which vented its\\ndisapproval in miniature growls until a low, querulous whine\\nfrom the lioness silenced him, then he stood at her side,\\nlooking first at her and then in the direction toward which she\\nlooked, cocking his little head first on one side and then on the\\nother.\\n\\n&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://www.gutenberg.org/ebooks/58874\">[continue reading at gutenberg.org]</a>\\n';\n\n}\nreturn __p\n}\n\n//# sourceURL=webpack:///./src/goldenlion.ejs?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var tapspace = __webpack_require__(/*! tapspace */ \"./node_modules/tapspace/index.js\")\nvar goldenlion = __webpack_require__(/*! ./goldenlion.ejs */ \"./src/goldenlion.ejs\")\n\nmodule.exports = () => {\n  // Tapspace-based website\n\n  var SpaceGroup = tapspace.SpaceGroup\n  var SpaceHTML = tapspace.SpaceHTML\n\n  var space = new tapspace.Space()\n  var view = new tapspace.SpaceView(space)\n  view.mount(document.getElementById('space'))\n  var lines = new SpaceGroup()\n  lines.setParent(space)\n\n  var RATIO = 0.9\n  var prev = null\n  var htmlLines = goldenlion({}).match(/[^\\r\\n]+/g)\n  htmlLines.forEach(function (line, index) {\n    var l = new SpaceHTML('<div>' + line + '</div>')\n    l.setSize(468, 20)\n    l.setParent(lines)\n    // Sum of finite geometric series\n    // var f = Math.round(30 * Math.pow(RATIO, index))\n    // var y = Math.round(32 * (1 - Math.pow(RATIO, index)) / (1 - RATIO))\n    var target = (prev === null) ? space.at(0, 0) : prev.atSW()\n    l.scale(l.atNW(), Math.pow(RATIO, index))\n    l.translate(\n      [l.atNW()],\n      [target]\n    )\n    prev = l\n  })\n\n  // Initial view position\n  view.fitScale(lines)\n  view.scale(lines.atMid(), 1.23)\n  // Make the view transformable\n  var viewtouch = new tapspace.Touchable(view, view)\n  var viewwheel = new tapspace.Wheelable(view, view)\n  viewtouch.start({ translate: true, scale: true, rotate: true, tap: true })\n  viewwheel.start({ scale: true })\n}\n\nmodule.exports()\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });